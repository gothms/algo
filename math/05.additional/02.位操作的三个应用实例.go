package _5_additional

/*
1. 验证奇偶数
	偶数的二进制最后一位总是 0，而奇数的二进制最后一位总是 1
		因此对于给定的某个数字，我们可以把它的二进制和数字 1 的二进制进行按位“与”的操作，取得这个数字的二进制最后一位，然后再进行判断
	我这里写了一段代码，比较了使用位运算和模运算的效率，我统计了进行 1 亿次奇偶数判断，使用这两种方法各花了多少毫秒
		如果在你的机器上两者花费的时间差不多，你可以尝试增加统计的次数。在我的机器上测试下来，同样次数的奇偶判断，使用位运算的方法耗时明显更低
2. 交换两个数字
	x = (x ^ y);
	y = x ^ y;
	x = x ^ y;
	把第一步代入第二步中，可以得到：
		y = (x ^ y) ^ y = x ^ (y ^ y) = x ^ 0 = x
	把第一步和第二步的结果代入第三步中，可以得到：
		x = (x ^ y) ^ x = (x ^ x) ^ y = 0 ^ y = y
3. 集合操作
	假设我们有两个集合{1, 3, 8}和{4, 8}
		那么第一个集合就可以转换为 10000101，第二个集合可以转换为 10001000
		那么这两个二进制数的按位与就是 10000000，只有第 8 位是 1，代表了两个集合的交为{8}
		而这两个二进制数的按位或就是 10001101，第 8 位、第 4 位、第 3 位和第 1 位是 1，代表了两个集合的并为{1, 3, 4, 8}
	说到这里，不禁让我想起 Elasticsearch 的 BitSet。我曾经使用 Elasticsearch 这个开源的搜索引擎来实现电商平台的搜索
		当时为了提升查询的效率，我使用了 Elasticsearch 的 Filter 查询。我研究了一下这个 Filter 查询的原理，发现它并没有考虑各种文档的相关性得分，因此它可以把文档匹配关键字的情况，转换成了一个 BitSet
		你可以把 BitSet 想成一个巨大的位数组。每一位对应了某篇文档是否和给定的关键词匹配，如果匹配，这一位就置 1，否则就置 0
		每个关键词都可以拥有一个 BitSet，用于表示哪些文档和这个关键词匹配。那么要查看同时命中多个关键词的文档有哪些，就是对多个 BitSet 求交集。利用上面介绍的按位与，这点是很容易实现的，而且效率相当之高

二分查找时的两个细节
	int middle = (left + right) / 2;
		改为：int middle = left + (right - left) / 2;
	关于误差百分比和绝对误差。在 Lesson3_2 中有这么一行：double delta = Math.abs((square / n) - 1);
		源码：https://time.geekbang.org/column/article/72243
		这里我使用了误差的百分比，也就是误差值占输入值 n 的比例
		其实绝对误差也是可以的，不过我在这里考虑了 n 的大小。比如，如果 n 是一个很小的正整数，比如个位数，那么误差可能要精确到 0.00001
		但是如果 n 是一个很大的数呢？比如几个亿，那么精确到 0.00001 可能没有多大必要，也许精确到 0.1 也就可以了
		所以，使用误差的百分比可以避免由于不同的 n，导致的迭代次数有过大差异
		由于这里 n 是大于 1 的正整数，所以可以直接拿平方值 square 去除以 n。否则，我们要单独判断 n 为 0 的情况，并使用绝对误差

关于迭代法、数学归纳法和递归
	迭代法和递归都是通过不断反复的步骤，计算数值或进行操作的方法
		迭代一般适合正向思维，而递归一般适合逆向思维
		而递归回溯的时候，也体现了正向递推的思维
		它们本身都是抽象的流程，可以有不同的编程实现
	对于某些重复性的计算，数学归纳法可以从理论上证明某个结论是否成立。如果成立，它可以大大节约迭代法中数值计算部分的时间
		不过，在使用数学归纳法之前，我们需要通过一些数学知识，假设命题，并证明该命题成立
	对于那些无法使用数学归纳法来证明的迭代问题，我们可以通过编程实现
		这里需要注意的是，广义上来说，递归也是迭代法的一种
		不过，在计算机编程中，我们所提到的迭代是一种具体的编程实现，是指使用循环来实现的正向递推，而递归是指使用函数的嵌套调用来实现的逆向递推。当然，两种实现通常是可以相互转换的

	循环的实现很容易理解，对硬件资源的开销比较小
		不过，循环更适合“单线剧情”
		而对于存在很多“分支剧情”的复杂案例而言，使用递归调用更加合适
	利用函数的嵌套调用，递归编程可以存储很多中间变量
		我们可以很轻松地跟踪不同的分支，而所有这些对程序员基本是透明的。如果这时使用循环，我们不得不自己创建并保存很多中间变量
		当然，正是由于这个特性，递归比较消耗硬件资源
	递归编程本身就体现了分治的思想，这个思想还可以延伸到集群的分布式架构中。最近几年比较主流的 MapReduce 框架也体现了这种思想
综合上面说的几点，你可以大致遵循这样的原则：
	如果一个问题可以被迭代法解决，而且是有关数值计算的，那你就看看是否可以假设命题，并优先考虑使用数学归纳法来证明
	如果需要借助计算机，那么优先考虑是否可以使用循环来实现。如果问题本身过于复杂，再考虑函数的嵌套调用，是否可以通过递归将问题逐级简化
	如果数据量过大，可以考虑采用分治思想的分布式系统来处理
*/
