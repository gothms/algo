package _1_basic

/*
在边有权重的图中，如何让计算机查找最优通路？
	假设你关心的是路上所花费的时间，那么权重就是从一点到另一点所花费的时间
	如果你关心的是距离，那么权重就是两点之间的物理距离

基于广度优先或深度优先搜索的方法
	一旦我们把地图转换成了图的模型，就可以运用广度优先搜索，计算从某个出发点，到图中任意一个其他结点的总耗时
		基本思路是，从出发点开始，广度优先遍历每个点，当遍历到某个点的时候，如果该点还没有耗时的记录，记下当前这条通路的耗时
		如果该点之前已经有耗时记录了，那就比较当前这条通路的耗时是不是比之前少。如果是，那就用当前的替换掉之前的记录
	实际上，地图导航和之前社交网络最大的不同在于，每个结点被访问了一次还是多次
		这种情形之下，使用广度优先找到的最短通路，不一定是最优的路线
		所以，对于在地图上查找最优路线的问题，无论是广度优先还是深度优先的策略，都需要遍历所有可能的路线，然后取最优的解
	在遍历所有可能的路线时，有几个问题需要注意
		第一，由于要遍历所有可能的通路，因此一个点可能会被访问多次
			当然，这个“多次“是指某个结点出现在不同通路中，而不是多次出现在同一条通路中
			因为我们不想让用户总是兜圈子，所以需要避免回路
		第二，如果某个结点 x 和起始点 s 之间存在多个通路，每当 x 到 s 之间的最优路线被更新之后，我们还需要更新所有和 x 相邻的结点之最优路线，计算复杂度会很高

一个优化的版本：Dijkstra 算法
	Dijkstra 算法的核心思想是
		对于某个结点，如果我们已经发现了最优的通路，那么就无需在将来的步骤中，再次考虑这个结点
	1.Dijkstra 算法的主要步骤
		首先你需要了解几个符号
			第一个是 source，我们用它表示图中的起始点，缩写是 s
			然后是 weight，表示二维数组，保存了任意边的权重，缩写为 w
			w[m, n]表示从结点 m 到结点 n 的有向边之权重，大于等于 0
				如果 m 到 n 有多条边，而且权重各自不同，那么取权重最小的那条边
			接下来是 min_weight，表示一维数组，保存了从 s 到任意结点的最小权重，缩写为 mw
				假设从 s 到某个结点 m 有多条通路，而每条通路的权重是这条通路上所有边的权重之和，那么 mw[m]就表示这些通路权重中的最小值
			最后是 Finish，表示已经找到最小权重的结点之集合，缩写为 F
				一旦结点被放入集合 F，这个结点就不再参与将来的计算
		初始的时候，Dijkstra 算法会做三件事情
			第一，把起始点 s 的最小权重赋为 0，也就是 mw[s] = 0
			第二，往集合 F 里添加结点 s，F 包含且仅包含 s
			第三，假设结点 s 能直接到达的边集合为 M，对于其中的每一个对端节点 m，则把 mw[m]设为 w[s, m]，同时对于所有其他 s 不能直接到达的结点，将通路的权重设为无穷大
		然后，Dijkstra 算法会重复下列两个步骤
			第一步，查找最小 mw
				从 mw 数组选择最小值，则这个值就是起始点 s 到所对应的结点的最小权重，并且把这个点加入到 F 中，针对这个点的计算就算完成了
			第二步，更新权重
				然后，我们看看，新加入 F 的结点 x，是不是可以直接到达其他结点。如果是，看看通过 x 到达其他点的通路权重，是否比这些点当前的 mw 更小，如果是，那么就替换这些点在 mw 中的值
			然后，重复上述两步，再次从 mw 中找出最小值，此时要求 mw 对应的结点不属于 F，重复上述动作，直到集合 F 包含了图的所有结点，也就是说，没有结点需要处理了
	2. 为什么每次都要选择最小的 mw？
		最小的、非无穷大的 mw 值，对应的结点是还没有加入 F 集合的、且和 s 有通路的那些结点
		拥有最小 mw 值的结点 x 不可能再找到更小的 mw 值，可以把它放入“已完成“的集合 F
		和广度优先或者深度优先的搜索相比，Dijkstra 算法可以避免对某些结点，重复而且无效的访问。因此，每次选择最小的 mw，就可以提升了搜索的效率
	3. 为什么每次都要看 x 直接相连的结点？
		我们已经确定 mw[x]是从点 s 到点 x 的最小权重，那么就可以把这个确定的值传播到和 x 直接相连、而且不在 F 中的结点
		通过这一步，我们就可以获得从点 s 到这些点、而且经过 x 的通路中最小的那个权重
		这一步和广度优先策略中的查找某个结点的所有相邻结点类似。但是，之后，Dijkstra 算法重复挑选最小权重的步骤，既没有遵从广度优先，也没有遵从深度优先
		即便如此，它仍然保证了不会遗漏任意一点和起始点 s 之间、拥有最小权重的通路，从而保证了搜索的覆盖率。你可能会奇怪，这是如何得到保证的？我使用数学归纳法，来证明一下
	我们的命题是，对于任意一个点，Dijkstra 算法都可以找到它和起始点 s 之间拥有最小权重的通路
		首先，当 n=1 的时候，也就是只有起始点 s 和另一个终止点的时候，Dijkstra 算法的初始化阶段的第 3 步，保证了命题的成立
		然后，我们假设 n=k-1 的时候命题成立，同时需要证明 n=k 的时候命题也成立
			命题在 n=k-1 时成立，表明从点 s 到 k-1 个终点的任何一个时，Dijkstra 算法都能找到拥有最小权重的通路
			那么再增加一个结点 x，Dijkstra 算法同样可以为包含 x 的 k 个终点找到最小权重通路

思考
	1.如果边的权重是负数，我们还能用今天讲的 Dijkstra 算法吗？
		如果全都是负数也是可以的，只要保证单调性
		如果同时有正有负就不行了，无法保证单调性，没法按照Dijkstra算法的方式进行优化
	2.如果地图中存在多条最优路径，也就是说多条路径的权重和都是相等的，那么我刚刚介绍的 Dijkstra 算法应该如何修改呢？
		就在找最小值时返回最小值集合，更新集合内所有点的直连边权值的最小值，且把集合点都加入F
*/
