package _1_basic

/*
在边有权重的图中，如何让计算机查找最优通路？
	假设你关心的是路上所花费的时间，那么权重就是从一点到另一点所花费的时间
	如果你关心的是距离，那么权重就是两点之间的物理距离

基于广度优先或深度优先搜索的方法
	一旦我们把地图转换成了图的模型，就可以运用广度优先搜索，计算从某个出发点，到图中任意一个其他结点的总耗时
		基本思路是，从出发点开始，广度优先遍历每个点，当遍历到某个点的时候，如果该点还没有耗时的记录，记下当前这条通路的耗时
		如果该点之前已经有耗时记录了，那就比较当前这条通路的耗时是不是比之前少。如果是，那就用当前的替换掉之前的记录
	实际上，地图导航和之前社交网络最大的不同在于，每个结点被访问了一次还是多次
		这种情形之下，使用广度优先找到的最短通路，不一定是最优的路线
		所以，对于在地图上查找最优路线的问题，无论是广度优先还是深度优先的策略，都需要遍历所有可能的路线，然后取最优的解
	在遍历所有可能的路线时，有几个问题需要注意
		第一，由于要遍历所有可能的通路，因此一个点可能会被访问多次
			当然，这个“多次“是指某个结点出现在不同通路中，而不是多次出现在同一条通路中
			因为我们不想让用户总是兜圈子，所以需要避免回路
		第二，如果某个结点 x 和起始点 s 之间存在多个通路，每当 x 到 s 之间的最优路线被更新之后，我们还需要更新所有和 x 相邻的结点之最优路线，计算复杂度会很高

一个优化的版本：Dijkstra 算法
	Dijkstra 算法的核心思想是
		对于某个结点，如果我们已经发现了最优的通路，那么就无需在将来的步骤中，再次考虑这个结点
	1.Dijkstra 算法的主要步骤
		首先你需要了解几个符号
			第一个是 source，我们用它表示图中的起始点，缩写是 s
			然后是 weight，表示二维数组，保存了任意边的权重，缩写为 w
			w[m, n]表示从结点 m 到结点 n 的有向边之权重，大于等于 0
				如果 m 到 n 有多条边，而且权重各自不同，那么取权重最小的那条边
			接下来是 min_weight，表示一维数组，保存了从 s 到任意结点的最小权重，缩写为 mw
				假设从 s 到某个结点 m 有多条通路，而每条通路的权重是这条通路上所有边的权重之和，那么 mw[m]就表示这些通路权重中的最小值
			最后是 Finish，表示已经找到最小权重的结点之集合，缩写为 F
				一旦结点被放入集合 F，这个结点就不再参与将来的计算
		初始的时候，Dijkstra 算法会做三件事情
			第一，把起始点 s 的最小权重赋为 0，也就是 mw[s] = 0
			第二，往集合 F 里添加结点 s，F 包含且仅包含 s
			第三，假设结点 s 能直接到达的边集合为 M，对于其中的每一个对端节点 m，则把 mw[m]设为 w[s, m]，同时对于所有其他 s 不能直接到达的结点，将通路的权重设为无穷大
		然后，Dijkstra 算法会重复下列两个步骤
			第一步，查找最小 mw。从 mw 数组选择最小值，则这个值就是起始点 s 到所对应的结点的最小权重，并且把这个点加入到 F 中，针对这个点的计算就算完成了
			











*/
