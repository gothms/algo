package _1_basic

/*
归并排序中的分治思想
	归并排序（merge sort）
		归并排序和快速排序都很好地体现了分治的思想
		很明显，归并排序算法的核心就是“归并”，也就是把两个有序的数列合并起来，形成一个更大的有序数列
	在归并排序中引入了分而治之（Divide and Conquer）的思想
		分而治之，我们通常简称为分治
		它的思想就是，将一个复杂的问题，分解成两个甚至多个规模相同或类似的子问题，然后对这些子问题再进一步细分，直到最后的子问题变得很简单，很容易就能被求解出来，这样这个复杂的问题就求解出来了
	我们把归并和分治的思想结合起来，这其实就是归并排序算法
		这种算法每次把数列进行二等分，直到唯一的数字，也就是最基本的有序数列
		然后从这些最基本的有序数列开始，两两合并有序的数列，直到所有的数字都参与了归并排序
	归并排序使用了分治的思想，而这个过程需要使用递归来实现
		分治的过程可以通过递归来表达，因此，归并排序最直观的实现方式就是递归

分布式系统中的分治思想
	例如，当需要排序的数组很大（比如达到 1024GB 的时候），我们没法把这些数据都塞入一台普通机器的内存里。该怎么办呢？
		有一个办法，我们可以把这个超级大的数据集，分解为多个更小的数据集（比如 16GB 或者更小），然后分配到多台机器，让它们并行地处理
		等所有机器处理完后，中央服务器再进行结果的合并。由于多个小任务间不会相互干扰，可以同时处理，这样会大大增加处理的速度，减少等待时间
		在单台机器上实现归并排序的时候，我们只需要在递归函数内，实现数据分组以及合并就行了
		而在多个机器之间分配数据的时候，递归函数内除了分组及合并，还要负责把数据分发到某台机器上
	图示：06.divide.png
		上图中的父结点，例如机器 1、2、3，它们都没有被分配排序的工作，只是在子结点的排序完成后进行有序数组的合并，因此集群的性能没有得到充分利用
		那么，另一种可能的数据切分方式是，每台机器拿出一半的数据给另一台机器处理，而自己来完成剩下一半的数据
如果分治的时候，只进行一次问题切分，那么上述层级型的分布式架构就可以转化为类似 MapReduce 的架构
	图示：06.mapReduce.png
	这里面主要有三个步骤用到了分治的思想
		1. 数据分割和映射
			分割是指将数据源进行切分，并将分片发送到 Mapper 上
			映射是指 Mapper 根据应用的需求，将内容按照键 - 值的匹配，存储到哈希结构中
			这两个步骤将大的数据集合切分为更小的数据集，降低了每台机器节点的负载，因此和分治中的问题分解类似
			不过，MapReduce 采用了哈希映射来分配数据，而普通的分治或递归不一定需要
		2. 归约
			归约是指接受到的一组键值配对，如果是键内容相同的配对，就将它们的值归并。这和本机的递归调用后返回结果的过程类似
			不过，由于哈希映射的关系，MapReduce 还需要洗牌的步骤，也就是将键 - 值的配对不断地发给对应的 Reducer 进行归约
			普通的分治或递归不一定需要洗牌的步骤
		3. 合并
			为了提升洗牌阶段的效率，可以选择减少发送到归约阶段的键 - 值配对
			具体做法是在数据映射和洗牌之间，加入合并的过程，在每个 Mapper 节点上先进行一次本地的归约
			然后只将合并的结果发送到洗牌和归约阶段。这和本机的递归调用后返回结果的过程类似

实际上，分治主要就是用在将复杂问题转化为若干个规模相当的小问题上
	分治思想通常包括问题的细分和结果的合并，正好对应于递归编程的函数嵌套调用和函数结果的返回
	细分后的问题交给嵌套调用的函数去解决，而结果合并之后交由函数进行返回。所以，分治问题适合使用递归来实现
	同时，分治的思想也可以帮助我们设计分布式系统和并行计算，细分后的问题交给不同的机器来处理，而其中的某些机器专门负责收集来自不同机器的处理结果，完成结果的合并

小结
	递归采用了和数学归纳法类似的思想，但是它用的是逆向递推，化繁为简，把复杂的问题逐步简化
	再加上分治原理，我们就可以更有效地把问题细分，进行并行化的处理

	而计算机编程中的函数嵌套调用，正好对应了数学中递归的逆向递推，所以你只要弄明白了数学递推式，就能非常容易的写出对应的递归编码
	这是为什么递归在编程领域有着非常广泛的应用

	不过，需要注意的是，递归编程在没有开始返回结果之前，保存了大量的中间结果，所以比较消耗系统资源
	这也是一般的编程语言都会限制递归的深度（也就是嵌套的次数）的原因

思考
	你有没有想过，在归并排序的时候，为什么每次都将原有的数组分解为两组，而不是更多组呢？如果分为更多组，是否可行？
		如果将数组分解成更多组（假设分成K组），是K路归并排序算法，当然是可以的，比如K=3时，是3路归并排序，依次类推
		3路归并排序是经典的归并排序（路归并排序）的变体，通过递归树方法计算等式T(n)= 3T(n/3)+ O(n)可以得到3路归并排序的时间复杂度为O(NlogN)，其中logN以3为底
		尽管3路合并排序与2路相比，时间复杂度看起来比较少，但实际上花费的时间会变得更高，因为合并功能中的比较次数会增加
*/
