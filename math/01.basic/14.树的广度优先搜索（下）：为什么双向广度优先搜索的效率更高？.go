package _1_basic

/*
如何更高效地求出两个用户间的最短路径？
	基本的做法是，从其中一个人出发，进行广度优先搜索，看看另一个人是否在其中
		如果不幸的话，两个人相距六度，那么即使是广度优先搜索，同样要达到万亿级的数量
	我们先看看，影响效率的问题在哪里？很显然，随着社会关系的度数增加，好友数量是呈指数级增长的
		如何控制这种增长呢？我这里介绍一种“双向广度优先搜索”。它巧妙地运用了两个方向的广度优先搜索，大幅降低了搜索的度数
核心思想
	假设有两个人 a、b。我们首先从 a 出发，进行广度优先搜索，记录 a 的所有一度好友 a1，然后看点 b 是否出现在集合 a1 中
	如果没有，就再从 b 出发，进行广度优先搜索，记录所有一度好友 b1，然后看 a 和 a1 是否出现在 b 和 b1 的并集中
	如果没有，就回到 a，继续从它出发的广度优先搜索，记录所有二度好友 a2，然后看 b 和 b1 是否出现在 a、a1 和 a2 三者的并集中
	如果没有，就回到 b，继续从它出发的广度优先搜索
	如此轮流下去，直到找到 a 的好友和 b 的好友的交集
	如果有交集，就表明这个交集里的点到 a 和 b 都是通路

	如果实验的数据量足够大（比如说结点在 1 万以上，边在 5 万以上），你应该能发现，双向的方法对时间和内存的消耗都更少
为什么双向搜索的效率更高呢？
	我们假设每个地球人平均认识 100 个人，如果两个人相距六度，单向广度优先搜索要遍历 100^6=1 万亿左右的人
		如果是双向广度优先搜索，那么两边各自搜索的人只有 100^3=100 万
	单向广度优先搜索之后查找匹配用户的开销更小啊
		的确如此，假设我们要知道结点 a 和 b 之间的最短路径，单向搜索意味着要在 a 的 1 万亿个好友中查找 b
		如果采用双向搜索的策略，从结点 a 和 b 出发进行广度优先搜索，每个方向会产生 100 万的好友，那么需要比较这两组 100 万的好友是否有交集

		假设我们使用哈希表来存储 a 的 1 万亿个好友
		并把搜索 b 是否存在其中的耗时记作 x，而把判断两组 100 万好友是否有交集的耗时记为 y，那么通常 x

		不过，综合考虑广度优先搜索出来的好友数量，双向广度优先搜索还是更有效

如何实现更有效地嵌套型聚合？
	聚合是数据分析中一个很常见的操作，它会根据一定的条件把记录聚集成不同的分组，以便我们统计每个分组里的信息
		目前，SQL 语言中的 GROUP BY 语句，Python 和 Spark 语言中 data frame 的 groupby 函数，Solr 的 facet 查询和 ElasticSearch 的 aggregation 查询，都可以实现聚合的功能
		我们可以嵌套使用不同的聚合，获得层级型的统计结果。但是，实际上，针对一个规模超大的数据集，聚合的嵌套可能会导致性能严重下降
	广度优先策略可以帮助我们大幅优化数据分析中的聚合操作
		案例：https://time.geekbang.org/column/article/77474
	如果一个项目用到排列组合的思想，我们需要在程序里使用大量的变量，来保存数据或者进行计算，这会导致内存和 CPU 使用量的急剧增加
		在允许的情况下，我们可以考虑使用广度优先策略，对排列组合所生成的树进行优化
		这样，我们就可以有效地缩减树中靠近根的结点数量，避免之后树的爆炸性生长

广度优先搜索，相对于深度优先搜索，没有函数的嵌套调用和回溯操作，所以运行速度比较快
	但是，随着搜索过程的进行，广度优先需要在队列中存放新遇到的所有结点，因此占用的存储空间通常比深度优先搜索多
	相比之下，深度优先搜索法只保留用于回溯的结点，而扩展完的结点会从栈中弹出并被删除
	所以深度优先搜索占用空间相对较少
	不过，深度优先搜索的速度比较慢，而并不适合查找结点之间的最短路径这类的应用

思考
	今天所说的双向广度优先比单向广度优先更高效，其实是要基于一个前提条件的
	你能否说出，在什么情况下，单向广度优先更高效呢？针对这种情况，又该如何优化双向广度优先呢？
		规模小不能体现双向优势
		另外，如果两个出发点a和b，如果a出发的图平均连接度明显大于b出发的图，那么从b单向广度可能效率更高
*/
