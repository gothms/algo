package _1_basic

/*
二分查找
	如果要使用二分查找查字典，我们首先要把整个字典排个序，然后每次都通过二分的方法来缩小搜索范围

前缀树（prefix tree），或者叫字典树（trie）
	从树顶层的根结点一直遍历到最下层的叶子结点，最终逐步构成单词前缀的过程

图论的一些基本概念
	前缀树是一种有向树
		那什么是有向树？顾名思义，有向树就是一种树，特殊的就是，它的边是有方向的
		而树是没有简单回路的连通图
		树是一种特殊的图，它是没有简单回路的连通无向图
	图
		如果一个图里所有的边都是有向边，那么这个图就是有向图
		如果一个图里所有的边都是无向边，那么这个图就是无向图
		既含有向边，又含无向边的图，称为混合图
		在有向图中，以结点 v 为出发点的边的数量，我们叫作 v 的出度。而以 v为 终点的边之数量，称为 v 的入度
	结点和边的交替序列组成的就是通路
		所以，通路上的任意两个结点其实就是互为连通的
		如果一条通路的起始点 v1和终止点 vn 相同，这种特殊的通路我们就叫作回路
		从起始点到终止点所经过的边之数量，就是通路的长度
	有向树
		有且仅有一个结点的入度为 0，这个结点被称为根
		除根以外的所有结点，入度都为 1。从树根到任一结点有且仅有一条有向通路

前缀树的构建和查询
	1. 构建前缀树
	2. 查询前缀树
	特殊情况
		如果还没到叶子结点的时候，待查的单词就结束了。这个时候要看最后匹配上的非叶子结点是否代表一个单词；如果不是，那说明被查单词并不在字典中
		如果搜索到前缀树的叶子结点，但是被查单词仍有未处理的字母。由于叶子结点没有子结点，这时候，被查单词不可能在字典中
		如果搜索到一半，还没到达叶子结点，被查单词也有尚未处理的字母，但是当前被处理的字母已经无法和结点上的字符匹配了。这时候，被查单词不可能在字典中
	前缀树的构建和查询这两者在本质上其实是一致的
		构建的时候，我们需要根据当前的前缀进行查询，然后才能找到合适的位置插入新的结点
		而且，这两者都存在一个不断重复迭代的查找过程，我们把这种方式称为深度优先搜索（Depth First Search）
	深度优先搜索（Depth First Search）
		由于单棵树中所有的结点都是连通的，所以通过深度优先的策略可以遍历树中所有的结点，因此也被称为深度优先遍历
满二叉树
	一棵高度为 n（高度从 1 开始计），且有 2^n-1 个结点的二叉树
	在高度为 k(0<k≤n）的这一层上，结点的数量为 2^(k-1)
	如果把树的根标为 0，每个结点的左子结点标为 0，每个结点的右子结点标为 1，那么把根到叶子结点的所有 0 或 1 连起来，就正好对应一个二进制数

思考
	现在给你一个字典，请尝试实现其前缀树，包括树的构建和查询两个过程。这里，字典可以用字符串数组来表示，每个字符串代表一个单词

*/
