package _1_basic

/*
社交网络中的好友问题
	社交网络就可以用图论来表示。而“相识关系”又可以分为单向和双向
		如果是双向关系，双方相互认识，因此直接用无向边就够了。今天讨论的都是无向图
	用两人之间最短通路的长度，来定义他们是几度好友
		寻找两个人之间的最短通路，或者说找出两人是几度好友，在社交中有不少应用
		例如，向你推荐新的好友、找出两人之间的关系的紧密程度、职场背景调查等等
	对于某个当前用户，LinkedIn 是这么来选择好友推荐的：
		被推荐的人和当前用户不是一度好友
		被推荐的人和当前用户是二度好友
			三度或者四度，就意味着两人间最短的通路也要经历 2 个或更多的中间人，他们的关系就比较疏远，互相添加好友的可能性就大大降低
深度优先搜索面临的问题
	要面临的问题是图中可能存在回路，这会增加通路的长度，这是我们在计算几度好友时所不希望的
		所以在使用深度优选搜索的时候，一旦遇到产生回路的边，我们需要将它过滤
		具体的操作是，判断新访问的点是不是已经在当前通路中出现过，如果出现过就不再访问
	如果过滤掉产生回路的边，从一个用户出发，我们确实可以使用深度优先的策略，搜索完他所有的 n 度好友，然后再根据关系的度数，从二度、三度再到四度进行排序
		这是个解决方法，但是效率太低了。为什么呢？
	社交关系的六度理论
		这个理论神奇的地方在于，它说地球上任何两个人之间的社交关系不会超过六度
		仔细想想，假设每个人平均认识 100 个人，那么你的二度好友就是 100^2
		以此类推，三度好友是 100^3，到五度好友就有 100 亿人了，已经超过了地球目前的总人口
		六度理论告诉我们，你的社会关系会随着关系的度数增加，而呈指数级的膨胀
		这意味着，在深度搜索的时候，每增加一度关系，就会新增大量的好友
	当我们在用户推荐中查看可能的好友时，基本上不会看完所有推荐列表，最多也就看个几十个人，一般可能也就看看前几个人
		所以，如果我们使用深度优先搜索，把所有可能的好友都找到再排序，那效率实在太低了

什么是广度优先搜索？
	广度优先搜索（Breadth First Search），也叫宽度优先搜索
		是指从图中的某个结点出发，沿着和这个点相连的边向前走，去寻找和这个点距离为 1 的所有其他点
		只有当和起始点距离为 1 的所有点都被搜索完毕，才开始搜索和起始点距离为 2 的点
		当所有和起始点距离为 2 的点都被搜索完了，才开始搜索和起始点距离为 3 的点，如此类推
	广度优先搜索其实就是横向搜索一棵树

	尽管广度优先和深度优先搜索的顺序是不一样的，它们也有两个共同点
		第一，在前进的过程中，我们不希望走重复的结点和边，所以会对已经被访问过的点做记号，而在之后的前进过程中，就只访问那些还没有被标记的点
			这一点上，广度优先和深度优先是一致的。有所不同的是，在广度优先中，如果发现和某个结点直接相连的点都已经被访问过，那么下一步就会看和这个点的兄弟结点直接相连的那些点，从中看看是不是有新的点可以访问
			而在深度优先中，如果到了某个点，发现和这个点直接相连的所有点都已经被访问过了，那么不会查看它的兄弟结点，而是回退到这个点的父节点，继续查看和父结点直接相连的点中是不是存在新的点
		第二，广度优先搜索也可以让我们访问所有和起始点相通的点，因此也被称为广度优先遍历
			如果一个图包含多个互不连通的子图，那么从起始点开始的广度优先搜索只能涵盖其中一个子图
			这时，我们就需要换一个还没有被访问过的起始点，继续广度优先遍历另一个子图
			广度优先搜索可以使用同样的方式来遍历有多个连通子图的图

如何实现社交好友推荐？
	和起始点更近的结点，会先更早地被发现。也就是说，越早被访问到的结点，越早地处理它
		需要用到队列这种先进先出（First In First Out）的数据结构
	那么在广度优先搜索中，队列是如何工作的呢？这主要分为以下几个步骤
		首先，把初始结点放入队列中
		然后，每次从队列首位取出一个结点，搜索所有在它下一级的结点
		接下来，把新发现的结点加入队列的末尾
		重复上述的步骤，直到没有发现新的结点为止

思考
	在计算机的操作系统中，我们常常需要查看某个目录下的文件或子目录
	现在给定一个目录的路径，请分别使用深度优先和广度优先搜索，列出该目录下所有的文件和子目录。对于子目录，需要进一步展示其下的文件和子目录，直到没有更多的子目录
*/
