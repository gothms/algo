package basic

/*
字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？

BF 算法（Brute Force）
	暴力匹配算法 / 朴素匹配算法
	主串：长度 n
	模式串：长度 m
	在主串中，检查起始位置分别是 0、1、2....n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的
	时间复杂度，最坏：O(n*m)
	在实际的开发中，是一个比较常用的字符串匹配算法
		实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长
		朴素字符串匹配算法思想简单，代码实现也非常简单，简单意味着不容易出错，如果有 bug 也容易暴露和修复
		在工程中，在满足性能要求的前提下，简单是首选。KISS（Keep it Simple and Stupid）设计原则
RK 算法（Rabin-Karp）
	BF 算法的升级版
	因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了
	时间复杂度：O(n)
	哈希算法设计：
		假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值
		查表：事先计算好 26^0、26^1、26^2……26^(m-1)，并且存储在一个长度为 m 的数组中
		存在问题：
			哈希值很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？
		解决：
			允许哈希冲突
			将每一个字母从小到大对应一个素数
			一个子串的哈希值跟模式串的哈希值相等的时候，需要再对比一下子串和模式串本身
		Go 的 RK 算法

思考
	如何在二维字符串矩阵查找另一个二维字符串矩阵呢？
	如 	主串			模式串
		d a b c		c a
		e f a d		e f
		c c a f
		d e f c
	// TODO
*/
