package basic

/*
动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题

“一个模型三个特征”
	什么样的问题适合用动态规划来解决呢？动态规划能解决的问题有什么规律可循呢？
“一个模型”：多阶段决策最优解模型
	一般是用动态规划来解决最优问题
	解决问题的过程，需要经历多个决策阶段
	每个决策阶段都对应着一组状态
	然后寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值
“三个特征”：最优子结构、无后效性和重复子问题
	最优子结构：最优子结构指的是，问题的最优解包含子问题的最优解
		可以通过子问题的最优解，推导出问题的最优解
		后面阶段的状态可以通过前面阶段的状态推导出来
	无后效性：只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性
		第一层含义是，在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的
		第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响
	重复子问题：
		不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态

“一个模型三个特征”实例剖析
	问题：
		假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角
		将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走
		把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？
	一个模型
		每个阶段都有向右走或者向下走两种决策
		每个阶段都会对应一个状态集合
		把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列
		min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度
	三个特征
		重复子问题
			回溯算法的递归树中，有重复的节点，即重复子问题
		无后效性
			想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态
			并不关心棋子是通过什么样的路线到达这两个位置的
			不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变
		最优子结构
			min_dist(i, j) 可以通过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来
			min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))

两种动态规划解题思路总结
	状态转移表法
	状态转移方程法

	不是每个问题都同时适合这两种解题思路
	有的问题可能用第一种思路更清晰，而有的问题可能用第二种思路更清晰
状态转移表法
	思路：
		1.一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决
			所以，当我们拿到问题的时候，可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树
		2.从递归树中，很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的
			以此来寻找规律，看是否能用动态规划解决
		3.两种处理思路（找到重复子问题之后）
			直接用回溯加“备忘录”，从执行效率上来讲，这跟动态规划的解决思路没有差别
			状态转移表法
	状态转移表法：
		1.画出一个状态表，一般都是二维的
			每个状态包含三个变量，行、列、数组值
		2.根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态
		3.将这个递推填表的过程，翻译成代码，就是动态规划代码了
	高维：
		如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维
		这个时候，就不适合用状态转移表法来解决了
			一方面是因为高维状态转移表不好画图表示
			另一方面是因为人脑确实很不擅长思考高维的东西
	解决矩阵最短路径的问题：
		1.回溯算法
			如何才能无重复又不遗漏地穷举出所有走法呢？
			穷举算法
		2.画递归树，寻找重复子问题
			对于 (i, j) 重复的节点，只需要选择 dist 最小的节点，继续递归求解，其他节点就可以舍弃了
		3.画二维状态表
			表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径
			按照决策过程，通过不断状态递推演进，将状态表填好
		4.翻译成代码
			初始化第 0 行，第 0 列，再按行来进行依次填充
状态转移方程法
	思路：有点类似递归的解题思路
		1.分析某个问题如何通过子问题来递归求解，也就是所谓的最优子结构
		2.根据最优子结构，写出递归公式，也就是所谓的状态转移方程
		3.两种代码实现
			递归加“备忘录”
			迭代递推
	状态转移方程是解决动态规划的关键：
		状态本身就不好定义
		状态转移方程也就更不好想到
	解决上面的矩阵最短路径的问题：
		// TODO
四种算法思想比较分析
	分类
		贪心、回溯、动态规划可以归为一类
			解决问题的模型，都可以抽象成多阶段决策最优解模型
		分治单独可以作为一类
			解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型
	回溯
		“万金油”
		基本上能用的动态规划、贪心解决的问题，都可以用回溯算法解决
		回溯算法相当于穷举搜索
		缺点：时间复杂度非常高，是指数级别的，对于大规模数据的问题，用回溯算法解决的执行效率就很低
		对于大规模数据的问题，用回溯算法解决的执行效率就很低了
	动态规划
		缺点：不是所有问题，都可以用动态规划来解决
		需要满足三个特征，最优子结构、无后效性和重复子问题
		区别：重复子问题
			分治算法：要求分割成的子问题，不能有重复子问题
			动态规划：动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题
	贪心
		动态规划算法的一种特殊情况
		解决问题起来更加高效，代码实现也更加简洁
		缺点：解决的问题也更加有限，需要满足
			最优子结构
			无后效性
			贪心选择性：通过局部最优的选择，能产生全局的最优选择

总结
	状态转移表法
		回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码
	状态转移方程法
		找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码

思考
	假设我们有几种不同币值的硬币 v1，v2，……，vn（单位是元）。如果我们要支付 w 元，求最少需要多少个硬币
	比如，我们有 3 种不同的硬币，1 元、3 元、5 元，我们要支付 9 元，最少需要 3 个硬币（3 个 3 元的硬币）
		lc-322
*/
