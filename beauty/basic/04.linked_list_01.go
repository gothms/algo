package basic

/*
链表（上）：如何实现LRU缓存淘汰算法?

Linked list
	通过“指针”将一组零散的内存块串联起来使用
	内存块称为链表的“结点”
	记录链上的下一个结点地址的指针叫后继指针 next

三种最常见的链表结构
	单链表
	双向链表
	循环链表
单链表
	插入/删除一个数据：并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的
	查询：根据后继指针依次遍历
循环链表：尾结点指针是指向链表的头结点
	处理的数据具有环型结构特点时，就特别适合采用循环链表
	约瑟夫问题
双向链表
	需要额外的两个空间来存储后继结点和前驱结点的地址，比单链表占用更多的内存空间
	双向遍历
	使用场景：
		在某些情况下的插入、删除等操作都要比单链表简单、高效
单链表 VS 双向链表：空间换时间
	删除/插入：两种情况
		删除结点中“值等于某个给定值”的结点
			O(n)的查询
		删除给定指针指向的结点
			双向链表可直接操作前驱节点，更易操作
	查询有序链表
		双向链表可以往前查询
双向循环链表

链表 VS 数组性能大比拼
	1.连续空间
	数组使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高
	而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读
	2.动态扩容
	数组的缺点是大小固定，一经声明就要占用整块连续内存空间
		如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”
		如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时
	链表本身没有大小的限制，天然地支持动态扩容，这也是它与数组最大的区别
	3.内存消耗
	如果代码对内存的使用非常苛刻，那数组就更适合你
	因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍
		而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片
		如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）
	4.和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高
时间 VS 空间
	对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化
	而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗

LRU 缓存淘汰算法
	使用场景
		CPU 缓存
		数据库缓存
		浏览器缓存
	常见三种策略
		先进先出策略 FIFO（First In，First Out）
		最少使用策略 LFU（Least Frequently Used）
		最近最少使用策略 LRU（Least Recently Used）
	缓存实际上就是利用了空间换时间的设计思想

链表实现 LRU 缓存淘汰策略：当有一个新的数据被访问时，从链表头开始遍历链表
	如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部
	如果此数据没有在缓存链表中，又可以分为两种情况
		如果此时缓存未满，则将此结点直接插入到链表的头部
		如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部
	缓存访问的时间复杂度 O(n)
优化：双向链表+散列表
	散列表：
		拉链，存储每个链表中的结点
	查找：O(1)
	删除：O(1)
	插入：O(1)

思考
	利用数组实现 LRU 缓存淘汰策略
	判断一个字符串是否是回文串：如果字符串是通过单链表来存储的
*/
