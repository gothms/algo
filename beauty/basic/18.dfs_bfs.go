package basic

/*
深度和广度优先搜索：如何找出社交网络中的三度好友关系？

六度分割理论
	具体是说，你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人
什么是“搜索”算法？
	深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的
		无权图的搜索算法
	图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”
	dfs
	bfs
	A* 启发式搜索
	IDA* 启发式搜索
	...

广度优先搜索（Breadth-First-Search）
	visited：记录已经被访问的顶点，用来避免顶点被重复访问
	queue：存储已经被访问、但相连的顶点还没有被访问的顶点
	prev：记录搜索路径。反向存储，prev[w]存储的是，顶点 w 是从哪个前驱顶点遍历过来的
	时间复杂度：O(V+E)，V 表示顶点的个数，E 表示边的个数
		对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1
		所以，广度优先搜索的时间复杂度也可以简写为 O(E)
	空间复杂度：O(V)
深度优先搜索（Depth-First-Search）
	回溯思想，借助栈来实现的。解决问题的过程，非常适合用递归来实现
	时间复杂度：O(E)，E 表示边的个数
		每条边最多会被访问两次，一次是遍历，一次是回退
	空间复杂度：O(V)，V 表示顶点的个数
		递归调用栈的最大深度不会超过顶点的个数

小结
	广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法
		比起其他高级的搜索算法，比如 A*、IDA* 等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法
		仅适用于状态空间不大，也就是说图不大的搜索
	广度优先搜索
		借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径
	度优先搜索
		回溯思想，非常适合用递归实现，即借助栈来实现的

思考
	能否用深度优先搜索来解决“找出一个用户的三度好友关系”呢？
		BFS
		DFS
	具体讲讲，如何将迷宫抽象成一个图吗？或者换个说法，如何在计算机中存储一个迷宫？
		拐弯是顶点
		路线是边
		路线长度是权重
*/
