package basic

/*
排序优化：如何实现一个通用的、高性能的排序函数？

如何选择合适的排序算法？
	小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法
	大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效
	快速排序 > 堆排序 > 归并排序
如何优化快速排序？
	最坏 O(n2) 时间复杂度出现的主要原因还是因为我们分区点选得不够合理
	最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多
		两个常用、简单的分区算法
		三数取中法
			首、尾、中间，分别取出一个数，取这 3 个数的中间值作为分区点
			更大的数据时，可能采用“五数取中”或“十数取中”等
		随机法
			从要排序的区间中，随机选择一个元素作为分区点
	避免堆栈溢出
		限制递归深度：一旦递归过深，超过了我们事先设定的阈值，就停止递归
		模拟调用栈：在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制

举例分析排序函数：Glibc qsort()
	优先使用归并排序来排序输入数据：小数据 1kb 2kb，空间换时间
	数据量比较大的时候，qsort() 会改为用快速排序算法来排序
		三数取中法
		自己实现一个堆上的栈，手动模拟递归
		// TODO
	插入排序：元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序
		在小规模数据面前，O(n^2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长
	哨兵

思考
	分析一下熟悉的语言中的排序函数都是用什么排序算法实现的呢？都有哪些优化技巧？

sort.Slice()
	insertionSort_func：插入排序，长度小于等于 12
	heapSort_func：堆排序
	pdqsort_func：快排
	partition_func
	choosePivot_func：分区算法
		[0,8]：选择一个静态支点
		[8,shortestNinther)：使用简单的三者中位数方法，i j k
		[shortestNinther,∞)：使用Tukey ninther方法，i-1 i i+1 取中(j k 同理)，再3数取中

		shortestNinther = 50
		swaps int	// 和逆序度有关，如果 == 12，则先反转原数据，并重新计算 pivot
		l := b - a
		var (
			swaps int
			i     = a + l/4*1
			j     = a + l/4*2
			k     = a + l/4*3
		)
	symMerge 合并两个排序子序列
		E:\gothmslee\algo\sort\2.5MergeSortGo.go

	// TODO
*/
