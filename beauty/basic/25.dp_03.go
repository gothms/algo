package basic

/*
动态规划实战：如何实现搜索引擎中的拼写纠错功能？

编辑距离（Edit Distance）：量化两个字符串的相似度
	将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）
	编辑距离越大，说明两个字符串的相似程度越小
	编辑距离就越小，说明两个字符串的相似程度越大
	两个完全相同的字符串来说，编辑距离就是 0
著名的编辑距离计算方式
	莱文斯坦距离（Levenshtein distance）
		允许增加、删除、替换字符这三个编辑操作
		表示两个字符串差异的大小
	最长公共子串长度（Longest common substring length）
		只允许增加、删除字符这两个编辑操作
		表示两个字符串相似程度的大小

如何编程计算莱文斯坦距离？
	多阶段决策最优解模型
		需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理
	回溯
		如果 a[i]与 b[j]匹配，递归考察 a[i+1]和 b[j+1]
		如果 a[i]与 b[j]不匹配，有多种处理方式可选：
			可以删除 a[i]，然后递归考察 a[i+1]和 b[j]
			可以删除 b[j]，然后递归考察 a[i]和 b[j+1]
			可以在 a[i]前面添加一个跟 b[j]相同的字符，然后递归考察 a[i]和 b[j+1]
				添加和删除有相同的效果
			可以在 b[j]前面添加一个跟 a[i]相同的字符，然后递归考察 a[i+1]和 b[j]
			可以将 a[i]替换成 b[j]，或者将 b[j]替换成 a[i]，然后递归考察 a[i+1]和 b[j+1]
	递归树
		查看是否存在重复子问题
		如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法
		状态包含三个变量 (i, j, edist)，edist 表示处理到 a[i]和 b[j]时，已经执行的编辑操作的次数
		对于 (i, j) 相同的节点，只需要保留 edist 最小的，即最少编辑次数
	状态转移方程
		如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：
			min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)
		如果：a[i]==b[j]，那么：min_edist(i, j)就等于：
			min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))
	画二维状态表
	代码实现
	// TODO
如何编程计算最长公共子串长度？
	定义状态：
		三个变量 (i, j, max_lcs)，max_lcs 表示 a[0...i]和 b[0...j]的最长公共子串长度
	回溯
		如果 a[i]与 b[j]互相匹配，将最大公共子串长度加一，并且继续考察 a[i+1]和 b[j+1]
		如果 a[i]与 b[j]不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：
			删除 a[i]，或者在 b[j]前面加上一个字符 a[i]，然后继续考察 a[i+1]和 b[j]
			删除 b[j]，或者在 a[i]前面加上一个字符 b[j]，然后继续考察 a[i]和 b[j+1]
	状态转移方程
		如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：
			max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))
		如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：
			max(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))
	代码实现
		// TODO
小技巧
	1.实例化几个测试数据，通过人脑去分析具体实例的解，然后总结规律，再尝试套用学过的算法
		人脑比较倾向于思考具象化的、摸得着看得见的东西，不适合思考过于抽象的问题
	2.多练

当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索,，这个功能是怎么实现的呢？
	拼写纠错最基本的原理
		当用户在搜索框内，输入一个拼写错误的单词时，我们就拿这个单词跟词库中的单词一一进行比较，计算编辑距离
		将编辑距离最小的单词，作为纠正之后的单词，提示给用户
	真正用于商用的搜索引擎，拼写纠错功能显然不会就这么简单
		1.单纯利用编辑距离来纠错，效果并不一定好
		2.词库中的数据量可能很大，搜索引擎每天要支持海量的搜索，所以对纠错的性能要求很高
	纠错效果不好优化思路举例
		1.不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的 TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词
			比如使用搜索热门程度来决定哪个单词作为拼写纠错单词
		2.用多种编辑距离计算方法，然后分别编辑距离最小的 TOP 10，然后求交集，用交集的结果，再继续优化处理
			比如使用莱文斯坦距离和最长公共子串长度
		3.通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词
			搜索引擎在拼写纠错的时候，首先在这个最常被拼错单词列表中查找
			如果一旦找到，直接返回对应的正确的单词
			这样纠错的效果非常好
		4.引入个性化因素
			针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词
			当用户输入错误的单词的时候，首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词
	纠错性能优化举例：分治思路
		1.如果纠错功能的 TPS 不高，我们可以部署多台机器，每台机器运行一个独立的纠错功能
			当有一个纠错请求的时候，通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词
		2.如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，可以将纠错的词库，分割到很多台机器
			当有一个纠错请求的时候，就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并行处理，分别得到编辑距离最小的单词
			然后再比对合并，最终决定出一个最优的纠错单词
	补充
		拼音检索
			如如 "刘得花"->"liudehua"->"刘德华"
		字形、语义等纠错策略
			传统搜索引擎中的查询词智能提示、纠错、同义词、近义词、同好词、相关搜索、知识图谱等系列功能
			统称为用户的意图识别模块

思考
	有一个数字序列包含 n 个不同的数字，如何求出这个序列中的最长递增子序列长度？
	比如 2, 9, 3, 6, 5, 1, 7 这样一组数字序列，它的最长递增子序列就是 2, 3, 5, 7，所以最长递增子序列的长度是 4
		动态规划
		贪心 + 二分查找
		lc-300
*/
