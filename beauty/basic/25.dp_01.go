package basic

/*
动态规划（Dynamic Programming）
	态规划比较适合用来求解最优问题，比如求最大值、最小值等等
	它可以非常显著地降低时间复杂度，提高代码的执行效率

// TODO 代码实现
0-1 背包问题
	对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？
	回溯算法：
		O(2^n)
	动态规划：
		1.回溯求解过程，画出递归树
			递归树中，有些子问题的求解是重复的
		2.“备忘录”（记忆化搜索）
			已经跟动态规划的执行效率基本上没有差别
		3.动态规划思路
			a)把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中
			b)把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合
				通过合并每一层重复的状态，就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量）
				成功避免了每层状态个数的指数级增长
			c)用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态
				比如：第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包
				用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态
		4.总结
			把问题分解为多个阶段，每个阶段对应一个决策
			记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进
		5.时间复杂度
			O(n*w)：n 表示物品个数，w 表示背包可以承载的总重量
		6.空间复杂度优化
			使用一维数组，代替二维数组
			但是遍历已放入背包的组合时，需要倒序遍历，避免重复计算
0-1 背包问题升级版：引入物品价值这一变量
	1.回溯算法，画出递归树，重复求解子问题
		f(i, cw, cv)
		i 表示即将要决策第 i 个物品是否装入背包
		cw 表示当前背包中物品的总重量
		cv 表示当前背包中物品的总价值
	2.用回溯算法，这个问题就没法再用“备忘录”解决	// TODO
		对于 (i, cw) 相同的不同状态，那我们只需要保留 cv 值最大的那个，继续递归处理，其他状态不予考虑
	3.动态规划	// TODO
		把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中
		用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态
		把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态
		时间复杂度是 O(n*w)，空间复杂度也是 O(n*w)

如何用最低总价实现“满减”活动	// TODO
	问题描述：
		淘宝的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”
		假设购物车中有 n 个（n>100）想买的商品，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件（200 元）
	思路：与 0-1 背包问题相似
		如果要购买的物品的总价格超过 200 太多，比如 1000，那这个“满减”就没有太大意义了。所以，可以限定总价值为 1001
		不仅要求大于等于 200 的总价格中的最小的，还要找出这个最小总价格对应都要购买哪些商品
		利用 states 数组，倒推出这个被选择的商品序列
			状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来
			检查这两个状态是否是可达的：
				states[i-1][j]可达，就说明没有选择购买第 i 个商品
				如果 states[i-1][j-value[i]]可达，那就说明我们选择了购买第 i 个商品
				如果两个都可达，就随意选择一个

总结
	大部分动态规划能解决的问题，都可以通过回溯算法来解决，只不过回溯算法解决起来效率比较低，时间复杂度是指数级的
	动态规划算法，在执行效率方面，要高很多，但是空间复杂度也提高了
		动态规划是一种空间换时间的算法思想
	贪心、分治、回溯、动态规划，这四个算法思想有关的理论知识，大部分都是“后验性”的
		在解决问题的过程中，往往是先想到如何用某个算法思想解决问题，然后才用算法理论知识，去验证这个算法思想解决问题的正确性

思考
	对“杨辉三角”改造，每个位置的数字可以随意填写，经过某个数字只能到达下面一层相邻的两个数字，请求出从最高层移动到最底层的最短路径长度
*/
