package basic

/*
排序（上）：为什么插入排序比冒泡排序更受欢迎？

如何分析一个“排序算法”？
	排序算法的执行效率
		最好情况、最坏情况、平均情况时间复杂度：及其对应的要排序的原始数据是什么样的
		时间复杂度的系数、常数 、低阶
		比较次数和交换（或移动）次数：基于比较的排序算法的执行过程，涉及两种操作
			元素比较大小
			元素交换或移动
	排序算法的内存消耗
		原地排序（Sorted in place）：特指空间复杂度是 O(1) 的排序算法
	排序算法的稳定性
		稳定性：待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变
			稳定排序算法
			不稳定排序算法
		示例：所有订单按金额排序，相同金额的订单按下单时间排序
			不稳定排序：先按金额排序，相同金额的区间再按下单时间排序，但实现起来很复杂
			稳定排序：先按下单时间排序，再按金额排序。可以保持金额相同的两个对象，在排序之后的前后顺序不变

满有序度：完全有序的数组
	满有序度 = 有序度 + 逆序度
有序度
	数组中具有有序关系的元素对的个数
	[6,5,4,3,2,1]：0
	[1,2,3,4,5,6]：n*(n-1)/2
	[2,4,3,1,5,6]：11
逆序度
	正好跟有序度相反

冒泡排序（Bubble Sort）
	优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作
	时间复杂度
		最好：O(n)
		最坏：O(n^2)
		平均：O(n^2)
			冒泡排序包含两个原子操作：比较和交换
			交换次数 = 逆序度
			平均情况下，需要 n*(n-1)/4 次交换操作（最好0，最坏n*(n-1)/2）
			比较操作肯定要比交换操作多
插入排序（Insertion Sort）
	动态排序，即动态地往有序集合中添加数据
	核心思想：取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序
	插入排序包含两种原子操作：比较和移动
	移动操作的次数 = 逆序度
	时间复杂度
		最好：O(n)
选择排序（Selection Sort）
	有点类似插入排序，也分已排序区间和未排序区间。每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾
	时间复杂度
		最好：O(n^2)
	不稳定排序算法

插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么更倾向于使用插入排序算法而不是冒泡排序算法呢？
	冒泡排序：不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。逆序度为 k，赋值 3k 次（Java）
	插入排序：移动次数，同冒泡。逆序度为 k，赋值 k 次
	插入排序：逆序度为 k，移动 k 个单位

	在小规模数据面前，O(n^2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长
希尔排序
	插入排序的优化
	E:\gothmslee\algo\sort\2.2ShellSort.go

思考
	如果数据存储在链表中，这三种排序算法还能工作吗？
		请分析比较次数
	如果能，那相应的时间、空间复杂度又是多少呢？
	// TODO

对于老师所提课后题，觉得应该有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。
一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。
综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。
*/
