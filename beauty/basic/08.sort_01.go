package basic

/*
排序（上）：为什么插入排序比冒泡排序更受欢迎？

如何分析一个“排序算法”？
	排序算法的执行效率
		最好情况、最坏情况、平均情况时间复杂度：及其对应的要排序的原始数据是什么样的
		时间复杂度的系数、常数 、低阶
		比较次数和交换（或移动）次数：基于比较的排序算法的执行过程，涉及两种操作
			元素比较大小
			元素交换或移动
	排序算法的内存消耗
		原地排序（Sorted in place）：特指空间复杂度是 O(1) 的排序算法
	排序算法的稳定性
		稳定性：待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变
			稳定排序算法
			不稳定排序算法
		示例：所有订单按金额排序，相同金额的订单按下单时间排序
			不稳定排序：先按金额排序，相同金额的区间再按下单时间排序，但实现起来很复杂
			稳定排序：先按下单时间排序，再按金额排序。可以保持金额相同的两个对象，在排序之后的前后顺序不变

满有序度
	满有序度 = 有序度 + 逆序度
有序度
	数组中具有有序关系的元素对的个数
	[6,5,4,3,2,1]：0
	[1,2,3,4,5,6]：n*(n-1)/2
	[2,4,3,1,5,6]：11
逆序度
	正好跟有序度相反

冒泡排序（Bubble Sort）
	优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作
	时间复杂度
		最好：O(n)
		最坏：O(n^2)
		平均：O(n^2)
			交换次数=逆序度
			平均情况下，需要 n*(n-1)/4 次交换操作（最好0，最坏n*(n-1)/2）
			比较操作肯定要比交换操作多
插入排序（Insertion Sort）
	动态排序
	核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序
	移动操作的次数=逆序度
选择排序（Selection Sort）
	不稳定排序算法

插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么更倾向于使用插入排序算法而不是冒泡排序算法呢？
	冒泡排序：不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。逆序度为 k，赋值 3k 次
	插入排序：同冒泡
	插入排序：逆序度为 k，移动 k 个单位

	在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长
希尔排序
	插入排序的优化

思考
	如果数据存储在链表中，这三种排序算法还能工作吗？
		请分析比较次数
	如果能，那相应的时间、空间复杂度又是多少呢？
*/

func BubbleSortTest(arr []int) {
	n := len(arr)
	for i := n - 1; i > 0; i-- {
		for j := 0; j < i; j++ {
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
		}
	}
}
func InsertSortTest(arr []int) {
	n := len(arr)
	for i := 1; i < n; i++ {
		j, v := i-1, arr[i]
		for j >= 0 && arr[j] > v {
			arr[j+1] = arr[j]
			j--
		}
		arr[j+1] = v
	}
}
func SelectSortTest(arr []int) {
	n := len(arr) - 1
	for i, idx := 0, 0; i < n; i++ {
		for j := i + 1; j <= n; j++ {
			if arr[idx] > arr[j] {
				idx = j
			}
		}
		arr[idx], arr[i] = arr[i], arr[idx]
	}
}
