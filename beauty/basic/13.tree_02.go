package basic

/*
二叉查找树（Binary Search Tree）
	二叉搜索树
	二叉排序树
	支持动态数据集合的快速插入、删除、查找操作
	在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值
二叉查找树的查找操作
二叉查找树的插入操作
二叉查找树的删除操作
	1.如果要删除的节点没有子节点
		只需要直接将父节点中，指向要删除节点的指针置为 null
	2.如果要删除的节点只有一个子节点（只有左子节点或者右子节点）
		只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点
	3.如果要删除的节点有两个子节点
		需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上
		再删除掉这个最小节点，因为最小节点肯定没有左子节点，应用上面两条规则来删除这个最小节点

		还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉
	4.二叉查找树的其他操作
		查找最大节点和最小节点、前驱节点和后继节点
		中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效
支持重复数据的二叉查找树
	方法一：
		通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上
	方法二：
		插入：
		如果碰到一个节点的值，与要插入数据的值相同，就将这个要插入的数据放到这个节点的右子树
		也就是说，把这个新插入的数据当作大于这个节点的值来处理
		查找：
		遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止
		这样就可以把键值等于要查找值的所有节点都找出来。
		删除：
		需要先查找到每个要删除的节点，然后再按删除操作的方法，依次删除
二叉查找树的时间复杂度分析
	最坏：O(n)
	最好：O(log n)，也就是 O(height)

既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？
	1.有序性
		散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序
		二叉查找树只需要中序遍历
	2.稳定性
		散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定
		尽管二叉查找树的性能不稳定，但是在工程中，最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)
	3.时间复杂度
		散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小
		所以实际的查找速度可能不一定比 O(logn) 快，加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高
	4.复杂性
		散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等
		平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定
	5.空间利用
		为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间

思考
	如何通过编程，求出一棵给定二叉树的确切高度呢？
*/

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func delete(root *TreeNode, v int) bool {
	var (
		pre  *TreeNode // 父节点
		curr = root    // 当前节点
	)
	for curr != nil && curr.Val != v { // 查询 v 节点
		pre = curr
		if v < curr.Val {
			curr = curr.Left
		} else {
			curr = curr.Right
		}
	}
	if curr == nil {
		return false
	}
	if curr.Left != nil && curr.Right != nil { // 有两个子节点
		p, c := curr, curr.Right // 找到右子树中最小的节点
		for c.Left != nil {
			p, c = c, c.Left
		}
		curr.Val, pre, curr = c.Val, p, c // 删除替换节点
	}
	var child *TreeNode
	if curr.Left != nil { // 只有一个子节点
		child = curr.Left
	} else if curr.Right != nil {
		child = curr.Right
	} // else 没有子节点
	if pre == nil { // 删除根节点
		root = child
	} else if pre.Left == curr {
		pre.Left = child
	} else {
		pre.Right = child
	}
	return true
}
