package basic

/*
二分查找（上）：如何用最省内存的方式实现快速查找功能？

二分查找
	针对的是一个有序的数据集合，查找思想有点类似分治思想
	每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0
对数时间复杂度 O(log n)
	一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效
	因为：
	大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶
	常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高
二分查找的实现（可以递归实现）
	循环退出条件
	mid 的取值
	low 和 high 的更新（区间上下界更新）：二分查找除了用循环来实现，还可以用递归来实现
	返回值选择

不适用场景
	依赖的是顺序表结构，简单点说就是数组（而不是链表等）
		需要按照下标随机访问元素
	针对的是有序数据
		频繁的插入和删除的动态数据集合，无论哪种方法，维护有序的成本都是很高的
		只能用在插入、删除操作不频繁，一次排序多次查找的场景中（动态数据集合，使用平衡二叉树）
		二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作
	数据量太小不适合二分查找
		数据量很小，顺序遍历
		但数据之间的比较操作非常耗时，不管数据量大小，推荐使用二分查找（如元素都是长度超过300的字符串）
		需要尽可能地减少比较次数，而比较次数的减少会大大提高性能
	数据量太大也不适合二分查找
		二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻

假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？
	8000万字节 = 76.3MB
	大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决
	但是 散列表 和 二叉树 都需要比较多的额外内存空间
	二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式

思考
	如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。
		lc-69
		// 牛顿迭代法，精确到小数点后 6 位
		func sqrtK(x float64) float64 {
			g := x
			d := 1e-6
			for g*g > x+d {
				g = (g + x/g) / 2 // 二分
			}
			//return g
			return math.Trunc(g*1e6+0.5) * d
		}
	如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？
		每次二分查找需要找到中间点，则移动指针次数为 n/2 次
		指针移动总次数 = n/2 + n/4 + ... + 1 = n-1
		O(n) 时间复杂度，对比顺序查找也是 O(n)，但二分查找时有更多的运算，所以会比顺序查找慢
*/
