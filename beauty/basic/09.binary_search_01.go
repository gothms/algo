package basic

/*
二分查找（上）：如何用最省内存的方式实现快速查找功能？

二分查找
	针对的是一个有序的数据集合，查找思想有点类似分治思想
	每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0
对数时间复杂度 O(log n)
	一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效
	因为：
	大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶
	常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高
二分查找的实现（可以递归实现）
	循环退出条件
	mid 的取值
	low 和 high 的更新
	返回值选择

不适用场景
	依赖的是顺序表结构，简单点说就是数组
		需要按照下标随机访问元素
	针对的是有序数据
		频繁的插入和删除的动态数据集合，无论哪种方法，维护有序的成本都是很高的
		只能用在插入、删除操作不频繁，一次排序多次查找的场景中（动态数据集合，使用平衡二叉树）
	数据量太小不适合二分查找
		数据量很小，顺序遍历
		但数据之间的比较操作非常耗时，不管数据量大小，推荐使用二分查找（如元素都是长度超过300的字符串）
	数据量太大也不适合二分查找
		二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻

假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？
	8000万字节 = 76.3MB
	大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决
	但是 散列表 和 二叉树 都需要比较多的额外内存空间

思考
	如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。
	如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？
*/
