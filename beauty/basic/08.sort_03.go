package basic

/*
桶排序（Bucket sort）
	核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序
	桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了
时间复杂度
	如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素
	每个桶内部使用快速排序，时间复杂度为 O(k * logk)
	m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))
	当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)
适用条件
	要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序
	数据在各个桶之间的分布是比较均匀的
	比较适合用在外部排序中。外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中
		某些桶的数据特别多，可以继续划分
示例
	有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？
	实现步骤：
		可以先扫描一遍文件，看订单金额所处的数据范围
		将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单
		第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推
		每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02...99）
		每个小文件中存储大约 100MB 的订单数据，就可以将这 100 个小文件依次放到内存中，用快排来排序
		按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中
	细节：
		订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的
		针对这些划分之后还是比较大的文件，可以继续划分
		直到所有的文件都能读入内存为止
	参见：23.divide_conquer.go

计数排序（Counting sort）
	计数排序其实是桶排序的一种特殊情况
	稳定排序写法
	非稳定排序写法
适用条件
	只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了
	而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数

基数排序（Radix sort）
	数据可以划分成高低位，位之间有递进关系
	按照每位来排序的排序算法要是稳定的
	根据每一位来排序，可以用桶排序或者计数排序，它们的时间复杂度可以做到 O(n)
示例：不等长排序，排序牛津字典中的 20 万个英文单词
	把所有的单词补齐到相同长度，位数不够的可以在后面补“0”
	再用基数排序进行排序
适用条件
	要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系
	如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了
	除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序
	否则，基数排序的时间复杂度就无法做到 O(n) 了

如何根据年龄给 100 万用户排序？
	计数排序

思考
	假设我们现在需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面
		但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？
	如果字符串中存储的不仅有大小写字母，还有数字
		要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？
*/
