package basic

/*
AC自动机：如何用多模式串匹配实现敏感词过滤功能？

多模式串匹配算法
	Trie
	AC 自动机

	单模式串匹配算法：一个主串中查找一个模式串
	多模式串匹配算法：一个主串中查找多个模式串

基于单模式串和 Trie 树实现的敏感词过滤
	单模式串匹配
		每个匹配过程都需要扫描一遍用户输入的内容
		如果敏感词很多，比如几千个，并且用户输入的内容很长，假如有上千个字符，那我们就需要扫描几千遍这样的输入内容
		多模式串匹配，只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率
	Trie 树
		对敏感词字典进行预处理，构建成 Trie 树结构
		如果敏感词字典动态更新了，比如删除、添加了一个敏感词，只需要动态更新一下 Trie 树就可以了
		用户输入的内容作为主串，从第一个字符开始，在 Trie 树中匹配。一直到模式串的最后
经典的多模式串匹配算法：AC 自动机，Aho-Corasick 算法
	AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了
	AC 自动机的构建，包含两个操作：
		将多个模式串构建成 Trie 树
		在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）
		Trie 树中的每一个节点都有一个失败指针，它的作用和构建过程，跟 KMP 算法中的 next 数组极其相似

失败指针
	可匹配后缀子串
		某个后缀子串可以匹配某个模式串的前缀，这个后缀子串叫作可匹配后缀子串
		失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点
	1.当要求某个节点的失败指针的时候，我们通过已经求得的、深度更小的那些节点的失败指针来推导
		也就是说，可以逐层依次来求解每个节点的失败指针
		所以，失败指针的构建过程，是一个按层遍历树的过程
			21.ac-failure-1.jpg
	2.已经求得某个节点 p 的失败指针之后，如何寻找它的子节点的失败指针呢？
		root 的失败指针为 NULL，也就是指向自己
		如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc
			21.ac-failure-2.1.jpg
		如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 q=q->fail（fail 表示失败指针，这里有没有很像 KMP 算法里求 next 的过程？）
			继续上面的查找，直到 q 是 root 为止
			21.ac-failure-2.2.jpg
		如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root
	3.最后构建完成之后的 AC 自动机
		21.ac-failure-3.jpg

构建失败指针代码实现
	参考：E:\gothmslee\algo\string\7.AC.go
		先构建 Trie 树
		再在 Trie 树上构建失败指针
	函数：buildFailurePointer
如何在 AC 自动机上匹配主串？
	AC 自动机从指针 p=root 开始，模式串是 b，主串是 a
	1.如果 p 指向的节点有一个等于 b[i]的子节点 x，我们就更新 p 指向 x
		这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串
		处理完之后，我们将 i 加一，继续这两个过程
	2.如果 p 指向的节点没有等于 b[i]的子节点，那失败指针就派上用场了，我们让 p=p->fail，然后继续这 2 个过程
	参考：E:\gothmslee\algo\string\7.AC.go
	函数：match

如何才能实现一个高性能的敏感词过滤系统呢？
	时间复杂度：构建
		将敏感词构建成 AC 自动机，包括构建 Trie 树以及构建失败指针
	Trie 树构建：O(m*len)
		时间复杂度是 O(m*len)，其中 len 表示敏感词的平均长度，m 表示敏感词的个数
	失败指针构建：O(k*len)
		假设 Trie 树中总的节点个数是 k
		每个节点构建失败指针的时候，while 循环中的 q=q->fail，每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len
		所以每个节点构建失败指针的时间复杂度是 O(len)
		整个失败指针的构建过程就是 O(k*len)
	时间复杂度：匹配
		O(n*len)
			for 循环依次遍历主串中的每个字符，时间复杂度是 O(n)
			匹配模式串时 q=q->fail 的时间复杂度是 O(len)
			所以总的匹配的时间复杂度就是 O(n*len)
		O(n)
			因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，可能近似于 O(n)
			所以 AC 自动机做敏感词过滤，性能非常高
	对比 Trie 树
		从时间复杂度上看，AC 自动机匹配的效率跟 Trie 树一样
		实际上，因为失效指针可能大部分情况下都指向 root 节点
			所以绝大部分情况下，在 AC 自动机上做匹配的效率要远高于刚刚计算出的比较宽泛的时间复杂度
		只有在极端情况下，AC 自动机的性能才会退化的跟 Trie 树一样

总结
	思想
		AC 自动机是基于 Trie 树的一种改进算法，它跟 Trie 树的关系，就像单模式串中，KMP 算法与 BF 算法的关系一样
		KMP 算法中有一个非常关键的 next 数组，类比到 AC 自动机中就是失败指针
		而且，AC 自动机失败指针的构建过程，跟 KMP 算法中计算 next 数组极其相似
		所以，要理解 AC 自动机，最好先掌握 KMP 算法，因为 AC 自动机其实就是 KMP 算法在多模式串上的改造
	AC 自动机算法包含两个部分
		将多个模式串构建成 AC 自动机
			分为两个小的步骤，一个是将模式串构建成 Trie 树，另一个是在 Trie 树上构建失败指针
		在 AC 自动机中匹配主串

思考
	各个字符串匹配算法的特点和比较适合的应用场景？
		单模式串匹配
			简单字符串
				Brute-Force
			模式串字符重复率低
				Rabin-Karp
				但考虑 hash 冲突
			模式串字符重复率高
				BoyerMoore
			算法题
				KMP
		多模式串匹配
			Trie 树
				前缀匹配
				内存富余，匹配量不大且有一定的前缀重复率
			AC 自动机
				大量的模式串精确匹配
*/
