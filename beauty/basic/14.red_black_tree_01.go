package basic

/*
红黑树（上）：为什么工程中都用红黑树这种二叉树？

平衡二叉树
	二叉树中任意一个节点的左右子树的高度相差不能大于 1
	完全二叉树
	满二叉树
平衡二叉查找树
	AVL树：高度平衡的二叉查找树
	红黑树：合格的平衡二叉查找树
		从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍
	伸展树（Splay Tree）
	树堆（Treap）
	...
	解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题
平衡的意义
	平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况
	这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些

如何定义一棵“红黑树”？
	Red-Black Tree，简称 R-B Tree
	红黑树中的节点，要么被标记为黑色，要么被标记为红色，且满足要求：
		根节点是黑色的
		每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据
			为了简化红黑树的代码实现而设置的
		任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的
		每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点
为什么说红黑树是“近似平衡”的？
	平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题
	“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化得太严重
	只需要分析，红黑树的高度是否比较稳定地趋近 log2(n)，就证明了红黑树是近似平衡的
证明：
	1.如果将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？
		二叉树就变成了四叉树，四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树
		所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小，不会超过 log2(n)
	2.把红色节点加回去，高度会变成多少呢？
		红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开
		加入红色节点之后，最长路径不会超过 2log2(n)

为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？
	Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化
		尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用
	AVL 的查询效率高，但为了维持这种高度的平衡，每次插入、删除都要做调整，就比较复杂、耗时
	R-B Tree 做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低
		插入、删除、查找各种操作性能都比较稳定
	对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，更倾向于这种性能稳定的平衡二叉查找树

总结
	红黑树的高度近似 log2(n)，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(log n)
	在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它
	它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，其实更倾向用跳表来替代它

思考
	动态数据结构支持动态的数据插入、删除、查找操作，除了红黑树，还有哪些呢？能对比一下各自的优势、劣势，以及应用场景吗？
		动态数据结构是支持动态的更新操作，里面存储的数据是时刻在变化的
		通俗一点讲，它不仅仅支持查询，还支持删除、插入数据
		而且，这些操作都非常高效。如果不高效，也就算不上是有效的动态数据结构了

		跳表
		散列表
		红黑树（平衡二叉查找树）
		B/B+树
*/
