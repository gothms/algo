package basic

/*
数组 Array
	是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据

随机访问
	a[i]_address = base_address + i * data_type_size
	线性表：
		数据最多只有前和后两个方向
	连续的内存空间和相同类型的数据：
		根据下标随机访问的时间复杂度为 O(1)，排好序的数组，二分查找为 O(log n)
低效的插入&删除
	插入
		有序数组中插入：O(n)
		无序数组中插入：将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置
	删除
		有序数组中删除：O(n)
		无序数组中删除：将数组元素最后一位的数据搬移到第 k 位，删除数组最后一位的元素
	数据搬移
		每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除
		当数组没有更多空间存储数据时，再触发执行一次真正的删除操作
	JVM垃圾回收算法
		多次删除思想，就是 JVM 标记清除垃圾回收算法的核心思想
警惕数组的访问越界问题
	访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误
	很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统
容器能否完全替代数组？
	动态扩容：最好在创建 容器 的时候事先指定数据大小
	场景：Java容器优先级低于数组
		ArrayList 无法存储基本类型
		数据大小事先已知
		多维数组

为什么数组要从 0 开始编号，而不是从 1 开始呢？
	从 0 开始：a[i]_address = base_address + i * data_type_size
	从 1 开始：a[i]_address = base_address + (i-1)*data_type_size
		每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令
		数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致
		为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始
	C 语言设计者用 0 开始计数数组下标
		很多语言中数组也并不是从 0 开始计数的，比如 Matlab
		甚至还有一些语言支持负数下标，比如 Python

思考
	JVM 的标记清除垃圾回收算法
	二维数组的内存寻址公式
*/
