package basic

/*
数组：为什么很多编程语言中数组都从0开始编号？

数组 Array
	是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据

随机访问
	a[i]_address = base_address + i * data_type_size
	线性表（Linear List）：
		每个线性表上的数据最多只有前和后两个方向
		除了数组，链表、队列、栈等也是线性表结构
		非线性表：比如二叉树、堆、图等。在非线性表中，数据之间并不是简单的前后关系
	连续的内存空间和相同类型的数据：
		正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”
		这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作
		根据下标随机访问数组元素：a[i]_address = base_address + i * data_type_size
		根据下标随机访问的时间复杂度为 O(1)，排好序的数组，二分查找为 O(log n)
低效的插入&删除
	插入
		有序数组中插入：O(n)
		无序数组中插入：O(1)
			将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置
			这个处理思想在快排中会用到
	删除
		有序数组中删除：O(n)
		无序数组中删除：O(1)
			将数组元素最后一位的数据搬移到第 k 位，删除数组最后一位的元素
	将多次删除操作集中在一起执行，删除的效率会提高很多
		可以先记录下已经删除的数据
		每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除
		当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移
	JVM垃圾回收算法
		多次删除思想，就是 JVM 标记清除垃圾回收算法的核心思想
警惕数组的访问越界问题
	示例
		int main(int argc, char* argv[]){
			int i = 0;
			int arr[3] = {0};
			for(; i<=3; i++){
			arr[i] = 0;
				printf("hello world\n");
			}
			return 0;
		}
	分析：无限打印“hello world”
		数组大小为 3，因为书写错误，导致 for 循环的结束条件错写为了 i<=3 而非 i<3，所以当 i=3 时，数组 a[3]访问越界
		在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的
		根据数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环
	数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理
		访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误
		很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统
容器能否完全替代数组？
	ArrayList 最大的优势：可以将很多数组操作的细节封装起来
	其他优势：支持动态扩容
		因为扩容操作涉及内存申请和数据搬移，是比较耗时的
		所以最好在创建 ArrayList 的时候事先指定数据大小
	场景：Java 容器优先级低于数组
		ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗
		数据大小事先已知，并且对数据的操作非常简单
		要表示多维数组时，用数组往往会更加直观
	总结
		对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能
		但如果是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选

为什么数组要从 0 开始编号，而不是从 1 开始呢？
	从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”
		从 0 开始：a[i]_address = base_address + i * data_type_size
		从 1 开始：a[i]_address = base_address + (i-1)*data_type_size
	从 1 开始编号
		每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令
		数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致
		为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始
	C 语言设计者用 0 开始计数数组下标
		很多语言中数组也并不是从 0 开始计数的，比如 Matlab
		甚至还有一些语言支持负数下标，比如 Python

思考
	JVM 的标记清除垃圾回收算法
		大多数主流虚拟机采用可达性分析算法来判断对象是否存活
			在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活
			只有当标记工作完成后，清理工作才会开始。
		不足：
			1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效
			2.空间问题。会产生不连续的内存空间碎片
	二维数组的内存寻址公式
		对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为
		address = base_address + ( i * n + j) * type_size
补充
	数组访问越界造成无限循环
	1.编译器的问题
		对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配
		示例程序，如果是内存地址递减的方式，就会造成无限循环
	2.跟编译器分配内存和字节对齐有关
		数组 3 个元素 加上一个变量 arr，4 个整数刚好能满足 8 字节对齐
		所以 i 的地址恰好跟在 arr[2] 后面，导致死循环
	3.建议去查函数调用的栈桢结构细节（操作系统或计算机体系结构的教材）
	4.参考：https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html
		和编译器的实现有关，gcc有一个编译选项（-fno-stack-protector）用于关闭堆栈保护功能
		默认情况下启动了堆栈保护，不管 i 声明在前还是在后，i 都会在数组之后压栈，只会循环 4 次
		如果关闭堆栈保护功能，则会出现死循环
*/
