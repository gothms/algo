package basic

/*
递归：如何用三行代码找到“最终推荐人”？

recursive
	递：去的过程
	归：回来的过程
递归需要满足的三个条件
	一个问题的解可以分解为几个子问题的解
	这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
	存在递归终止条件

如何编写递归代码？
	写出递推公式，找到终止条件
		写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式
		然后再推敲终止条件，最后将递推公式和终止条件翻译成代码
	误区：
		试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区
	关键：
		把递归抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤

递归代码要警惕堆栈溢出
	函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈
	系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险
避免出现堆栈溢出
	递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错
	存在问题
		最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。实时计算，代码过于复杂
		最大深度比较小，就可以用这种方法，否则这种方法并不是很实用
递归代码要警惕重复计算
	记忆化+散列表（方案之一）
递归代码的其他问题
	时间效率：递归代码里很多函数调用，较大时
	空间复杂度：每次递归会在内存栈中保存一次现场数据

怎么将递归代码改写为非递归代码？：递归代码都可以改为迭代循环
	递归本身就是借助栈来实现的，只不过使用的栈是系统或者虚拟机本身提供的
	可以在内存堆上实现栈，手动模拟入栈、出栈过程

给定一个用户 ID，如何查找这个用户的“最终推荐人”？
	递归代码的问题：
		如果递归很深，可能会有堆栈溢出的问题
		如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题
	除了限制递归深度，更好的解决
		检测“环”：拓扑排序
			advance 01.topological_kahn.go
		实际上，因为每次都只是查找一个用户的最终推荐人，所以并不需要动用复杂的拓扑排序算法
		而只需要记录已经访问过的用户 ID，当用户 ID 第二次被访问的时候，就说明存在环，也就说明存在脏数据
	IO 密集
		如果某个用户是经过层层推荐才来注册的，那我们获取他的最终推荐人的时候，就需要多次访问数据库，性能显然就不高了
		参考 selective.05.project.go

思考
	规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？

经验
	有“递”有“归”
		在递归函数体中，完全可以不用每遇到递归调用都展开并进入下一层（step into）
		而是可以直接假定下一层调用能够正确返回，然后该干嘛就继续干嘛（step over）
		这样的话，只需要保证最深一层的逻辑，也就是递归的终止条件正确即可
	原因
		管在哪一层，都是在执行递归函数这同一份代码，不同的层只有一些状态数据不同而已
		所以只需要保证递归函数代码逻辑的正确性，就确保了运行时任意一层的结果正确性
	递归 & 堆栈
		递归树中从根节点到树中任意节点的路径，都对应着某个时刻的函数调用链组成的堆栈
			递归越深的节点越靠近栈顶，也越早返回
		递归的背后是一棵树，递归的执行过程，就是在这棵树上做深度遍历的过程
			每次进入下一层（“递”）就是压栈
			每次退出当前层（“归”）就是出栈
		所有的入栈、出栈形成的脉络就组成了递归树的形态。递归树是静态逻辑背景，而当前活跃堆栈是当前动态运行前景
	卡特兰数：
		1.计算某个长度为 n 的入栈序列可以有多少种出栈序列
		2.计算包含 n 个节点的二叉树有多少种形状
		两道题的结果是相等的
			每种二叉树形状的中序遍历都能够对应上一种出栈顺序
*/
