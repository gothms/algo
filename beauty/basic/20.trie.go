package basic

/*
Trie 树
	字典树
	专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题
	Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起
		根节点不包含任何信息
		每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）
基本操作
	将字符串集合构造成 Trie 树
	在 Trie 树中查询一个字符串
如何实现一棵 Trie 树？
	借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针
	查找的时间复杂度：O(k)，k 表示要查找的字符串的长度

Trie 树真的很耗内存吗？
	Trie 树是非常耗内存的，用的是一种空间换时间的思路
	Trie 树的本质是避免重复存储一组字符串的相同前缀子串，但是现在每个字符（对应一个节点）的存储远远大于 1 个字节
		每个节点都要存储一个长度为 26 的数组（如果字符串中包含从 a 到 z 这 26 个字符）
			如果字符串中不仅包含小写字母，还包含大写字母、数字、甚至是中文，那需要的存储空间就更多了
		每个数组元素要存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）
	优化空间：两种
		将每个节点中的数组换成其他数据结构，如有序数组、跳表、散列表、红黑树等
			如果用有序数组，可以通过二分查找的方法，快速查找到某个字符应该匹配的子节点的指针
			但是，在往 Trie 树中插入一个字符串的时候，我们为了维护数组中数据的有序性，就会稍微慢了点
		缩点优化
			对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并
			可以节省空间，但却增加了编码难度

VS
	Trie 树：在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有极其严苛的要求
		字符串中包含的字符集不能太大，否则存储空间可能就会浪费很多
		要求字符串的前缀重合比较多，不然空间消耗会变大很多
		如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug
			这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做
		通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣
	散列表、红黑树的比较
		不需要自己去实现，直接利用编程语言中提供的现成类库就行了
总结
	精确匹配查找 & 动态集合数据的查找
		更适合用散列表或者红黑树来解决
	查找前缀匹配的字符串
		Trie 树

如何利用 Trie 树，实现搜索关键词的提示功能？
	假设关键词库由用户的热门搜索关键词组成，将这个词库构建成一个 Trie 树
深入问题
	上述思路是针对英文的搜索关键词提示，对于更加复杂的中文来说，词库中的数据又该如何构建成 Trie 树呢？
	如果词库中有很多关键词，在搜索提示的时候，用户输入关键词，作为前缀在 Trie 树中可以匹配的关键词也有很多，如何选择展示哪些内容呢？
	像 Google 这样的搜索引擎，用户单词拼写错误的情况下，Google 还是可以使用正确的拼写来做关键词提示，这个又是怎么做到的呢？
		// TODO
自动输入补全
	输入法自动补全功能
	IDE 代码编辑器自动补全功能
	浏览器网址输入的自动补全功能
	...

思考
	如果现在给你一个很大的字符串集合，比如包含 1 万条记录，如何通过编程量化分析这组字符串集合是否比较适合用 Trie 树解决呢？
	也就是如何统计字符串的字符集大小，以及前缀重合的程度呢？
*/
