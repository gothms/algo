package basic

/*
哈希算法（上）：如何防止数据库中的用户信息被脱库？

什么是哈希算法？
	Hash 算法 / 散列算法
	将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法
	而通过原始数据映射之后得到的二进制值串就是哈希值

	无论要哈希的文本有多长、多短，通过 MD5 哈希之后，得到的哈希值的长度都是相同的，而且得到的哈希值看起来像一堆随机数，完全没有规律
设计一个优秀的哈希算法
	从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）
	对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同
	散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小
	哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值
应用
	安全加密
	唯一标识
	数据校验
	散列函数
	负载均衡
	数据分片
	分布式存储

安全加密
	MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）
		哈希值是 128 位的 Bit 长度
	SHA（Secure Hash Algorithm，安全散列算法）
	DES（Data Encryption Standard，数据加密标准）
	AES（Advanced Encryption Standard，高级加密标准）
	格外重要：
	第一点是很难根据哈希值反向推导出原始数据
	第二点是散列冲突的概率要很小

	鸽巢原理（也叫抽屉原理）：为什么哈希算法无法做到零冲突？
		一般情况下，哈希值越长的哈希算法，散列冲突的概率越低
		在有限的时间和资源下，哈希算法还是很难被破解的
		越复杂、越难破解的加密算法，需要的计算时间也越长
		密码学界也一直致力于找到一种快速并且很难被破解的哈希算法，需要权衡破解难度和计算时间
唯一标识
	在海量的图库中，搜索一张图片是否存在
		元信息（如图片名称）比对：不准确
		二进制码串比对：高耗时
		唯一标识/信息摘要
	把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中
		如果散列表中存在，还要做全量比对
数据校验
	BT 下载软件，校验文件块的安全、正确、完整
		通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中
		当文件块下载完成之后，通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对
散列函数：平均性 & 执行效率
	相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多
	散列函数对于散列算法计算得到的值，是否能反向解密也并不关心
	散列函数用的散列算法一般都比较简单，比较追求效率
		散列函数中用到的散列算法，更加关注散列后的值是否能平均分布
		散列函数执行的快慢，也会影响散列表的性能

你会如何存储用户密码这么重要的数据吗？仅仅 MD5 加密一下存储就够了吗？
	选择相对安全的加密算法，比如 SHA 等，对用户密码进行加密之后再存储
	字典攻击：
		维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值跟脱库后的密文比对
		应对：引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度
	补充
		黑客拿到脱机的数据后，通过彩虹表匹配可以轻松破解常用密码
		密码123456加盐后可能是12ng34qq56zz
		可在头、中、尾加盐，甚至加的盐可以是随机的

小结
	安全加密
		权衡安全性和计算时间来决定用哪种哈希算法
	唯一标识
		对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据
	校验数据的完整性和正确性
	散列函数
		更加看重的是散列的平均性和哈希算法的执行效率

思考
	区块链是一个很火的领域，它被很多人神秘化，不过其底层的实现原理并不复杂。其中，哈希算法就是它的一个非常重要的理论基础
	讲一讲区块链使用的是哪种哈希算法吗？是为了解决什么问题而使用的呢？
		区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体
		区块头保存着 自己区块体 和 上一个区块头 的哈希值
		因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了
		区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到
*/
