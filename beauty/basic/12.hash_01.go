package basic

/*
哈希算法（上）：如何防止数据库中的用户信息被脱库？

什么是哈希算法？
	Hash 算法 / 散列算法
	将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法
	而通过原始数据映射之后得到的二进制值串就是哈希值

	无论要哈希的文本有多长、多短，通过 MD5 哈希之后，得到的哈希值的长度都是相同的，而且得到的哈希值看起来像一堆随机数，完全没有规律
设计一个优秀的哈希算法
	从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）
	对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同
	散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小
	哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值
应用
	安全加密
	唯一标识
	数据校验
	散列函数
	负载均衡
	数据分片
	分布式存储

安全加密
	MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）
		哈希值是 128 位的 Bit 长度
	SHA（Secure Hash Algorithm，安全散列算法）
	DES（Data Encryption Standard，数据加密标准）
	AES（Advanced Encryption Standard，高级加密标准）
	格外重要：
	第一点是很难根据哈希值反向推导出原始数据
	第二点是散列冲突的概率要很小

	鸽巢原理（也叫抽屉原理）：为什么哈希算法无法做到零冲突？
		一般情况下，哈希值越长的哈希算法，散列冲突的概率越低
		在有限的时间和资源下，哈希算法还是很难被破解的
		越复杂、越难破解的加密算法，需要的计算时间也越长
		密码学界也一直致力于找到一种快速并且很难被破解的哈希算法，需要权衡破解难度和计算时间
唯一标识
	在海量的图库中，搜索一张图片是否存在
		元信息（如图片名称）比对：不准确
		二进制码串比对：高耗时
		唯一标识/信息摘要
	把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中
		如果散列表中存在，还要做全量比对
数据校验
	BT 下载软件，校验文件块的安全、正确、完整
		通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对
散列函数：平均性 & 执行效率
	相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多
	散列函数对于散列算法计算得到的值，是否能反向解密也并不关心
	散列函数用的散列算法一般都比较简单，比较追求效率
		散列函数中用到的散列算法，更加关注散列后的值是否能平均分布
		散列函数执行的快慢，也会影响散列表的性能

你会如何存储用户密码这么重要的数据吗？仅仅 MD5 加密一下存储就够了吗？
	选择相对安全的加密算法，比如 SHA 等，对用户密码进行加密之后再存储
	字典攻击：
		维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值跟脱库后的密文比对
		应对：引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度

思考
	讲一讲区块链使用的是哪种哈希算法吗？是为了解决什么问题而使用的呢？
*/
