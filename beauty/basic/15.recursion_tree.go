package basic

/*
递归树：如何借助树来求解递归算法的时间复杂度？

递归树
	树的一种特殊应用

递归树与时间复杂度分析
	借助归并排序来看看，如何用递归树，来分析递归代码的时间复杂度

	每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关，每一层归并操作消耗的时间记作 n
	归并排序递归树是一棵满二叉树，满二叉树的高度大约是 log2(n)
	归并排序递归实现的时间复杂度就是 O(n log n)

分析快速排序的时间复杂度
	假设平均情况下，每次分区之后，两个分区的大小比例为 1:k，当 k=9
	每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n
	递归树中最短的一个路径每次都乘以 1/10，最长的一个路径每次都乘以 9/10
	通过计算，从根节点到叶子节点的最短路径是 log10(n)，最长的路径是 log10/9(n)
	所以，遍历数据的个数总和就介于 n log10(n) 和 n log10/9(n) 之间，即 O(n log n)
分析斐波那契数列的时间复杂度
	f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2
	所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n
	如果每次都是 −2，那最短路径大约就是 n/2
	第 k 层的时间消耗就是 2k−1，那整个算法的总的时间消耗就是每一层时间消耗之和
		如果路径长度都为 n，那这个总和就是 2n−1
		如果路径长度都是 n/2 ，那整个算法的总的时间消耗就是 2^(n/2)−1
	时间复杂度就介于 O(2^n) 和 O(2^(n/2)) 之间
分析全排列的时间复杂度
// TODO 实现全排列
	第一层分解有 n 次交换操作
	第二层有 n 个节点，每个节点分解需要 n−1 次交换，所以第二层总的交换次数是 n∗(n−1)
	第 k 层总的交换次数就是 n∗(n−1)∗(n−2)∗...∗(n−k+1)
	总共 n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1
		O(n!)

时间复杂度分析方法
	递推公式
		比如归并排序的时间复杂度、快速排序的最好情况时间复杂度
	递归树
		比如快速排序的平均时间复杂度
	两个都不怎么适合使用
		比如二叉树的递归前中后序遍历

思考
	1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？
	请用递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。
		f(n) = f(n-1)*2 - f(n-4)
*/
