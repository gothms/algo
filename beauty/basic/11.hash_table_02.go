package basic

/*
散列表（中）：如何打造一个工业级水平的散列表？

散列表碰撞攻击基本原理
	散列表的查询效率跟散列函数、装载因子、散列冲突等都有关系
	恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里
	使用基于链表的冲突解决方法，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)
	因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的

如何设计散列函数？
	散列函数的设计不能太复杂
		过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能
	散列函数生成的值要尽可能随机并且均匀分布
		尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀
	综合考虑各种因素，关键字的长度、特点、分布、还有散列表的大小等
	几个常用的、简单的散列函数的设计方法
		数据分析法
		“进位”求余取模
		直接寻址法
		平方取中法
		折叠法
		随机数法
		...
装载因子过大了怎么办？
	没有频繁插入和删除的静态数据集合，根据数据的特点、分布等，设计出完美的、极少冲突的散列函数
	动态散列表，数据集合是频繁变动的，随着数据慢慢加入，装载因子就会慢慢变大
	动态扩容
		散列表的大小变了，数据的存储位置也变了，需要通过散列函数重新计算每个数据的存储位置
		插入：最坏 O(n)，摊还分析 O(1)
		删除：动态缩容，如果对空间消耗非常敏感，可以在装载因子小于某个值之后，启动动态缩容
	装载因子阈值的设置：权衡时间、空间复杂度
		内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值
		内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1
	如何避免低效的扩容？
		插入数据时，“一次性”扩容的机制不合适
		将扩容操作穿插在插入操作的过程中，分批完成
			查询：先查新散列表，再查老散列表
如何选择冲突解决方法？
	开放寻址法：ThreadLocalMap 线性探测
	链表法：Java LinkedHashMap
开放寻址法
	优点：
		数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度
		序列化起来比较简单
	缺点：
		删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据
		所有的数据都存储在一个数组中，冲突的代价更高
			所以装载因子的上限不能太大，也导致这种方法比链表法更浪费内存空间
	适用场景：
		当数据量比较小
		装载因子小的时候：只能适用装载因子小于 1 的情况
链表法
	优点：
		对内存的利用率比开放寻址法要高
			因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好
		对大装载因子的容忍度更高
			即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多
	缺点：
		要存储指针，对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍
			如果存储的是大对象，指针的内存消耗就可以忽略了
		结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响
		包含指针，序列化起来就没那么容易
	适用场景：
		适合存储大对象
		大数据量的散列表
		更加灵活，支持更多的优化策略
			红黑树代替链表，抵御散列碰撞攻击
			将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树

工业级散列表举例分析：Java HashMap
	初始大小：16。如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能
	装载因子和动态扩容：默认0.75，动态扩容为原来的两倍大小。当 HashMap 中元素个数超过 0.75*capacity 时启动扩容
	散列冲突解决方法：链表法，JDK1.8中，链表长度超过8，转换为红黑树，结点个数小于8，又转化为链表（红黑树要维护平衡）
	散列函数：追求的是简单高效、分布均匀
		int hash(Object key) {
			int h = key.hashCode();	// 返回的是 Java 对象的 hash code
			return (h ^ (h >>> 16)) & (capicity -1); //capicity表示散列表的大小
		}
		public int hashCode() {	// String 类型的对象的 hashCode()
		  int var1 = this.hash;
		  if(var1 == 0 && this.value.length > 0) {
			char[] var2 = this.value;
			for(int var3 = 0; var3 < this.value.length; ++var3) {
			  var1 = 31 * var1 + var2[var3];
			}
			this.hash = var1;
		  }
		  return var1;
		}

如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？
如果这是一道面试题或者是摆在你面前的实际开发问题，你会从哪几个方面思考呢？
	工业级的散列表应该具有哪些特性？
		支持快速地查询、插入、删除操作
		内存占用合理，不能浪费过多的内存空间
		性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况
	如何实现这样一个散列表呢？从这三个方面来考虑设计思路（还要结合具体的业务场景、具体的业务数据来具体分析）
		设计一个合适的散列函数
		定义装载因子阈值，并且设计动态扩容策略
		选择合适的散列冲突解决方法

思考
	Go 语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？
	// TODO
*/
