package beauty

/*
recursive
	递：去的过程
	归：回来的过程
递归需要满足的三个条件
	一个问题的解可以分解为几个子问题的解
	这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
	存在递归终止条件

如何编写递归代码？
	写出递推公式，找到终止条件
		写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式
		然后再推敲终止条件，最后将递推公式和终止条件翻译成代码
	误区：
		试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区
	关键：
		把递归抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤

递归代码要警惕堆栈溢出
	函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈
	系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险
避免出现堆栈溢出
	递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错
	存在问题
		最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。实时计算，代码过于复杂
		最大深度比较小，就可以用这种方法，否则这种方法并不是很实用
递归代码要警惕重复计算
	记忆化+散列表（方案之一）
递归代码的其他问题
	时间效率：递归代码里很多函数调用，较大时
	空间复杂度：每次递归会在内存栈中保存一次现场数据

怎么将递归代码改写为非递归代码？：递归代码都可以改为迭代循环
	递归本身就是借助栈来实现的，只不过使用的栈是系统或者虚拟机本身提供的
	可以在内存堆上实现栈，手动模拟入栈、出栈过程

给定一个用户 ID，如何查找这个用户的“最终推荐人”？
	递归代码的问题：
		如果递归很深，可能会有堆栈溢出的问题
		如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题
	除了限制递归深度，更好的解决
		检测“环”	// TODO

思考
	规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？
*/
