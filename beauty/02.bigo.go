package beauty

/*
事后统计法：局限性
	测试结果非常依赖测试环境
	测试结果受数据规模的影响很大
大O复杂度表示法
	T(n)=O(f(n))
		T(n)：代码执行的时间
		n：数据规模的大小
		f(n)：每行代码执行的次数总和
	实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势
		所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度
	忽略
		低阶
		常量
		系数

时间复杂度：渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系
	只关注循环执行次数最多的一段代码
	加法法则：总复杂度等于量级最大的那段代码的复杂度
	乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
非多项式量级
	NP（Non-Deterministic Polynomial，非确定多项式）问题
	非多项式时间复杂度的算法其实是非常低效的算法
多项式量级
	O(1)
	O(log n)：对数阶
	O(n)
	O(n log n)：线性对数阶
	O(n^2)：平方阶
	O(n^3)：立方阶
	...
	O(n^k)：k次方阶

空间复杂度：渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系
	除了原本的数据存储空间外，算法运行还需要额外的存储空间

最好情况时间复杂度（best case time complexity）
	在最理想的情况下，执行这段代码的时间复杂度
最坏情况时间复杂度（worst case time complexity）
	在最糟糕的情况下，执行这段代码的时间复杂度
平均情况时间复杂度（average case time complexity）
	加权平均时间复杂度 或者 期望时间复杂度
均摊时间复杂度（amortized time complexity
	平均复杂度只在某些特殊情况下才会用到
	而均摊时间复杂度应用的场景比它更加特殊、更加有限，是一种特殊的平均时间复杂度
	分析方法：摊还分析（或者叫平摊分析）
*/

// add 示例函数，仅用于分析均摊时间复杂度
func add(v int) {
	if i_02 >= l_02 {
		l_02 <<= 1
		nArr := make([]int, l_02)
		copy(nArr, arr_02)
		arr_02 = nArr
	}
	arr_02[i_02] = v
	i_02++
}

var (
	arr_02 = make([]int, 1)
	i_02   int
	l_02   = len(arr_02)
)
