package advance

/*
B+树：MySQL数据库索引是如何实现的？

在工作中，为了加速数据库中数据的查找速度，常用的处理思路是，对表中数据创建索引
数据库索引是如何实现的呢？底层使用的是什么数据结构和算法呢？

算法解析
	解决问题的前提是定义清楚问题
	尝试用学过的数据结构解决这个问题
	改造二叉查找树来解决这个问题

解决问题的前提是定义清楚问题
	如何定义清楚问题呢？
		1.对问题进行详细的调研
		2.对一些模糊的需求进行假设，来限定要解决的问题的范围
	假设：要解决的问题，只包含两个常用的需求
		根据某个值查找数据，比如 select * from user where id=1234
		根据区间值来查找某些数据，比如 select * from user where id > 1234 and id < 2345
	非功能性需求：时间 & 空间
		比如安全、性能、用户体验等等
		对于数据结构和算法，着重考虑性能方面的需求
		性能方面的需求，主要考察时间和空间两方面，也就是执行效率和存储空间
尝试用学过的数据结构解决这个问题
	支持快速查询、插入等操作的动态数据结构
		散列表、平衡二叉查找树、跳表
	散列表
		不能支持按照区间快速查找数据
	平衡二叉查找树
		对树进行中序遍历，可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据
	跳表
		插入、查找、删除数据，对应的时间复杂度是 O(logn)
		支持按照区间快速地查找数据
			定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止
			这期间遍历得到的数据就是满足区间值的数据
	B+树
		是通过二叉查找树演化而来

改造二叉查找树来解决这个问题
	改造过程
		06.b+_basic.jpg
			树中的节点并不存储数据本身，而是只是作为索引
			每个叶子节点串在一条链表上，链表中的数据是从小到大有序的
			经过改造之后的二叉树，看起来很像跳表呢
		区间查找：
			拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后
			再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止
			所有遍历到的数据，就是符合区间值的所有数据
		问题：
			要为几千万、上亿的数据构建索引，如果将索引存储在内存中
			尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多
		内存分析：
			给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节
			需要大约 1GB 的内存空间
			给 10 张表建立索引，需要 10GB 的内存空间，那对内存的需求是无法满足的
		时间换空间：
			把索引存储在硬盘中，而非内存中
			常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的
			读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍
			在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多
		时间复杂度分析：
			每个节点的读取（或者访问），都对应一次磁盘 IO 操作
			树的高度就等于每次查询数据时磁盘 IO 操作的次数
		优化：
			重点就是尽量减少磁盘 IO 操作，也就是，尽量降低树的高度
			那如何降低树的高度呢？
		m叉树：如果根节点存储在内存中，其他节点存储在磁盘中
			二叉树：16个数据，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作
			五叉树：高度只有 2，查找一个数据，对应只需要 2 次磁盘操作
			100叉树：一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据
		将 m 叉树实现 B+ 树索引，用代码实现
		// TODO 代码实现
		计算m：多大才最合适呢？
			对于相同个数的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小，那 m 叉树中的 m 是不是越大越好呢？
			页：
				不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB
				这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据
			如果要读取的数据量超过一页的大小，就会触发多次 IO 操作
			所以，在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小
			读取一个节点，只需要一次磁盘 IO 操作
		索引的弊端
			会让写入数据的效率下降，为什么呢？
			数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因
	B+树
		插入数据 & 索引的更新
			对于一个 B+ 树来说，m 值是根据页的大小事先计算好的，每个节点最多只能有 m 个子节点
			在往数据库中写入数据的过程中，就有可能使索引中某些节点的子节点个数超过 m，这个节点的大小超过了一个页的大小
			读取这样一个节点，就会导致多次磁盘 IO 操作
		节点分裂
			将这个节点分裂成两个节点
			节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个
				同样的方法，将父节点也分裂成两个节点
			示例：06.b+_insert.jpg
				B+ 树是一个三叉树
				限定叶子节点中，数据的个数超过 2 个就分裂节点
				非叶子节点中，子节点的个数超过 3 个就分裂节点
		删除数据
			正是因为要时刻保证 B+ 树索引是一个 m 叉树，所以，索引的存在会导致数据库写入的速度降低
			不光写入数据会变慢，删除数据也会变慢
				类似跳表中删除数据的处理思路
				频繁的数据删除，就会导致某些节点中，子节点的个数变得非常少
				长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率
		m/2阈值
			在 B+ 树中，子节点个数的阈值等于 m/2
			如果某个节点的子节点个数小于 m/2，就将它跟相邻的兄弟节点合并
			合并之后节点的子节点个数有可能会超过 m
				借助插入数据时候的处理方法，再分裂节点
			示例：06.b+_delete.jpg
				B+ 树是一个五叉树
				限定叶子节点中，数据的个数少于 2 个就合并节点
				非叶子节点中，子节点的个数少于 3 个就合并节点
	B+树 vs 跳表
		B+ 树的结构和操作，跟跳表非常类似
		理论上讲，对跳表稍加改造，也可以替代 B+ 树，作为数据库的索引实现的
		B+ 树发明于 1972 年
		跳表发明于 1989 年

总结
	B+树特点
		每个节点中子节点的个数不能超过 m，也不能小于 m/2
		根节点的子节点个数可以不超过 m/2，这是一个例外
		m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表
		通过链表将叶子节点串联在一起，这样可以方便按区间查找
		一般情况，根节点会被存储在内存中，其他节点存储在磁盘中
	B-树
		B- 树就是 B 树，英文翻译都是 B-Tree，这里的“-”并不是相对 B+ 树中的“+”，而只是一个连接符
		B 树实际上是低级版的 B+ 树，或者说 B+ 树是 B 树的改进版
	B+ vs B
		B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据
		B 树中的叶子节点并不需要链表来串联
		B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树

思考：参见留言区
	1.B+ 树中，将叶子节点串起来的链表，是单链表还是双向链表？为什么？
	2.对平衡二叉查找树进行改造，将叶子节点串在链表中，就支持了按照区间来查找数据
		散列表也经常跟链表一块使用，如果我们把散列表中的结点，也用链表串起来，能否支持按照区间查找数据呢？
*/
