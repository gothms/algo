package advance

/*
拓扑排序：如何确定代码源文件的编译依赖关系？

拓扑排序
	基于有向无环图的一个算法

如何确定代码源文件的编译依赖关系？
	编译器通过分析源文件或者程序员事先写好的编译配置文件（比如 Makefile 文件），来获取这种局部的依赖关系
那编译器又该如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？

算法解析
	数据结构：
		把源文件与源文件之间的依赖关系，抽象成一个有向图
		每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边
		不仅要是有向图，还要是一个有向无环图（图中一旦出现环，拓扑排序就无法工作了）
	拓扑排序实现：两种方法
		Kahn 算法：贪心算法思想
		DFS：深度优先遍历

Kahn 算法
	1.找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中
		如果某个顶点入度为 0， 也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了
	2.并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 1）
	3.循环执行上面的过程，直到所有的顶点都被输出
	时间复杂度：O(V+E)（V 表示顶点个数，E 表示边的个数）
		图可能不是连通的，有可能是有好几个不连通的子图构成
		所以，E 并不一定大于 V，两者的大小关系不确定
		则，在表示时间复杂度的时候，V、E 都要考虑在内
	// TODO 代码实现
DFS 算法
	1.通过邻接表构造逆邻接表（或者直接实现逆邻接表）
	2.递归处理每个顶点
		对于顶点 vertex 来说，先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己
	时间复杂度：O(V+E)（V 表示顶点个数，E 表示边的个数）
	// TODO 代码实现

总结
	凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决
	拓扑排序能检测图中环的存在
		对于 Kahn 算法来说，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是 0 的顶点，那就说明，图中存在环
		案例：basic 07.recursive.go，递归查找最终推荐人的时候，可能会因为脏数据，造成存在循环推荐
			实际上，因为每次都只是查找一个用户的最终推荐人，所以并不需要动用复杂的拓扑排序算法
			而只需要记录已经访问过的用户 ID，当用户 ID 第二次被访问的时候，就说明存在环，也就说明存在脏数据
			// TODO 代码实现
		案例：检查数据库中的所有用户之间的推荐关系了，有没有存在环的情况
			把用户之间的推荐关系，从数据库中加载到内存中，然后构建成今天讲的这种有向图数据结构
			再利用拓扑排序，就可以快速检测出是否存在环了

思考
	1.表示依赖关系的时候，如果 a 先于 b 执行，我们就画一条从 a 到 b 的有向边
		反过来，如果 a 先于 b，我们画一条从 b 到 a 的有向边，表示 b 依赖 a
		Kahn 算法和 DFS 算法还能否正确工作呢？如果不能，应该如何改造一下呢？
	2.两种拓扑排序算法的实现思路，Kahn 算法和 DFS 深度优先搜索算法
		如果换做 BFS 广度优先搜索算法，还可以实现吗？
*/
