package advance

/*
搜索：如何用A*搜索算法实现游戏中的寻路功能？

魔兽世界、仙剑奇侠传这类 MMRPG 游戏，当人物处于游戏地图中的某个位置的时候
用鼠标点击另外一个相对较远的位置，人物就会自动地绕过障碍物走过去，这个功能是怎么实现的呢？

算法解析
	初步分析
		人物的起点就是他当下所在的位置，终点就是鼠标点击的位置
		找一条从起点到终点的路径，这条路径要绕过地图中所有障碍物，并且看起来要是一种非常聪明的走法
			走的路不能太绕
			短路径显然是最聪明的走法
			如果图非常大，那 Dijkstra 最短路径算法的执行耗时会很多
			超级大的地图和海量的寻路请求，算法的执行效率太低，这显然是无法接受的
		像出行路线规划、游戏寻路，这些真实软件开发中的问题，一般情况下，我们都不需要非得求最优解（也就是最短路径）
		在权衡路线规划质量和执行效率的情况下，只需要寻求一个次优解就足够了
	如何快速找出一条接近于最短路线的次优路线呢？
		A* 算法
			快速的路径规划算法，是对 Dijkstra 算法的优化和改造
		Dijkstra 实现思路
			用一个优先级队列，来记录已经遍历到的顶点以及这个顶点与起点的路径长度
		示例：07.a_search_dijkstra-demo.jpg
			最先被搜索到的顶点依次是 1，2，3
			这个搜索方向跟我们期望的路线方向（s 到 t 是从西向东）是反着的，路线搜索的方向明显“跑偏”了
			在地图中，尽管 1，2，3 三个顶点离起始顶点最近，但离终点却越来越远
		算法优化：启发函数 & 曼哈顿距离
			从这个顶点到终点的路径长度，是未知的。虽然确切的值无法提前知道，但是可以用其他估计值来代替
			通过这个顶点跟终点之间的直线距离，也就是欧几里得距离，来近似地估计这个顶点跟终点的路径长度（注意：路径长度跟直线距离是两个概念）
			这个距离记作 h(i)（i 表示这个顶点的编号），专业的叫法是启发函数（heuristic function）
			欧几里得距离的计算公式，会涉及比较耗时的开根号计算，使用更加高效的曼哈顿距离
		曼哈顿距离（Manhattan distance）
			两点之间横纵坐标的距离之和
			func Manhattan(v1, v2 Vertex) { // Vertex表示顶点
				return abs(v1.x - v2.x) + abs(v1.y - v2.y)
			}
		估价函数（evaluation function）
			f(i)=g(i)+h(i)：根据估计函数，判断哪个顶点最先出队列
			g(i)：顶点与起点之间的路径长度 g(i)
			h(i)：启发函数（曼哈顿距离）

A*算法的实现
	// TODO
	实现：A* vs Dijkstra
		定义区别
			顶点 Vertex 类的定义，多了 x，y 坐标
		主要逻辑区别
			1.优先级队列构建的方式不同
				A* 算法是根据 f 值（也就是刚刚讲到的 f(i)=g(i)+h(i)）来构建优先级队列
				而 Dijkstra 算法是根据 dist 值（也就是 g(i)）来构建优先级队列
			2.A* 算法在更新顶点 dist 值的时候，会同步更新 f 值
			3.循环结束的条件也不一样
				Dijkstra 算法是在终点出队列的时候才结束
				A* 算法是一旦遍历到终点就结束
	尽管 A* 算法可以更加快速地找到从起点到终点的路线，但是它并不能像 Dijkstra 算法那样，找到最短路线。这是为什么呢？
		Dijkstra
			回溯：07.a_search_dijkstra-back.jpg
				穷举所有从 s 到达 t 的不同路径，然后对比找出最短的那个
			动态规划思想：07.a_search_dijkstra-dp.jpg
				在回溯基础上，对回溯搜索进行了剪枝，只保留起点到某个顶点的最短路径，继续往外扩展搜索
				但它实际上也考察到了所有从起点到终点的路线，所以才能得到最优解
		循环结束条件不一样
			Dijkstra 算法是在终点出队列的时候才结束，A* 算法是一旦遍历到终点就结束
			对于 Dijkstra 算法来说，当终点出队列的时候，终点的 dist 值是优先级队列中所有顶点的最小值
				即便再运行下去，终点的 dist 值也不会再被更新了
			对于 A* 算法来说，一旦遍历到终点，我们就结束 while 循环，这个时候，终点的 dist 值未必是最小值
		A*
			利用贪心算法的思路
			每次都找 f 值最小的顶点出队列，一旦搜索到终点就不在继续考察其他顶点和路线了
			所以，它并没有考察所有的路线，也就不可能找出最短路径了
如何借助 A* 算法解决游戏寻路问题？
	将地图抽象成边权值为 1 的有向图
	1.抽象成方块
		游戏中的地图并不像我们现实生活中那样，存在规划非常清晰的道路，更多的是宽阔的荒野、草坪等
		所以，没法像 Dijkstra 把岔路口抽象成顶点，把道路抽象成边
		而是把整个地图分割成一个一个的小方块
		在某一个方块上的人物，只能往上下左右四个方向的方块上移动
	2.边权值为 1 的有向图
		每个方块看作一个顶点
		两个方块相邻，就在它们之间，连两条有向边，并且边的权值都是 1
		问题就转化成了，在一个有向有权图中，找某个顶点到另一个顶点的路径问题

总结
	A* 算法属于一种启发式搜索算法（Heuristically Search Algorithm）
		IDA* 算法
		蚁群算法
		遗传算法
		模拟退火算法
		...
	工程中
		实际的软件开发中的路线规划问题，往往并不需要非得找最短路线
		鉴于启发式搜索算法能很好地平衡路线质量和执行效率，它在实际的软件开发中的应用更加广泛
		比如，地图 App 中的出行路线规划问题，不仅可以使用 Dijkstra 算法
			也可以利用启发式搜索算法来实现

思考
	迷宫问题”是否可以借助 A* 算法来更快速地找到一个走出去的路线呢？
	如果可以，请具体讲讲该怎么来做；如果不可以，请说说原因。
*/
