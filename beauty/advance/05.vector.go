package advance

/*
向量空间：如何实现一个简单的音乐推荐系统？

算法解析
	解决思路
		找到跟你口味偏好相似的用户，把他们爱听的歌曲推荐给你
		找出跟你喜爱的歌曲特征相似的歌曲，把这些歌曲推荐给你
	基于相似用户做推荐
	基于相似歌曲做推荐

基于相似用户做推荐
	如何找到跟你口味偏好相似的用户呢？或者说如何定义口味偏好相似呢？
	用户相似 1.0
		听类似歌曲的人，看作口味相似的用户
		只需要遍历所有的用户，对比每个用户跟你共同喜爱的歌曲个数，并且设置一个阈值
		如果你和某个用户共同喜爱的歌曲个数超过这个阈值，就把这个用户看作跟你口味相似的用户
		把这个用户喜爱但你还没听过的歌曲，推荐给你
	如何定义用户对某首歌曲的喜爱程度呢？
		通过用户的行为，来定义这个喜爱程度，比如：
		单曲循环	分享	收藏	搜索	听完	没听过	跳过
		5		4	3	2	1	0		-1
		对用户建立歌曲喜爱程度的对应表：
		参见 05.vector_user-song.jpg
	有了用户对歌曲的喜爱程度的对应表之后，如何来判断两个用户是否口味相似呢？
	用户相似 2.0：使用 欧几里得距离（Euclidean distance） 计算两个用户之间的相似度
		每个用户对所有歌曲的喜爱程度，都用一个向量表示
		计算出两个向量之间的欧几里得距离，作为两个用户的口味相似程度的度量
		欧几里得距离越小，则在高维空间中靠得越近，两个用户的口味越相似
欧几里得距离（Euclidean distance）：计算两个向量之间的距离
	向量（vector）
		K 维空间中的某个位置，写作（X1，X2，X3，…，XK）
	向量之间的距离：欧几里得距离
		二维：(x1,x2) 与 (y1,y2) 之间的距离
			d = sqrt((x1-y1)^2 + (x2-y2)^2)
		三维：(x1,x2,x3) 与 (y1,y2,y3) 之间的距离
			d = sqrt((x1-y1)^2 + (x2-y2)^2 + (x3-y3)^2)
		k维：(x1,x2,...,xk) 与 (y1,y2,...,yk) 之间的距离
			d = sqrt((x1-y1)^2 + (x2-y2)^2 + ... + (xk-yk)^2)

基于相似歌曲做推荐
	如何判断两首歌曲是否相似呢？
		对于计算机来说，判断两首歌曲是否相似，需要通过量化的数据来表示
		应该通过什么数据来量化两个歌曲之间的相似程度呢？
	特征项
	歌曲相似 1.0
		对歌曲定义一些特征项，比如是伤感的还是愉快的，是摇滚还是民谣，是柔和的还是高亢的等等
		给每个歌曲的每个特征项打一个分数，这样每个歌曲就都对应一个特征项向量
		基于这个特征项向量，来计算两个歌曲之间的欧几里得距离。欧几里得距离越小，表示两个歌曲的相似程度越大
		缺点：
			前提是能够找到足够多，并且能够全面代表歌曲特点的特征项
			还要人工给每首歌标注每个特征项的得分，是一个非常大的工程
			人工标注有很大的主观性，也会影响到推荐的准确性
	欧几里得距离
	歌曲相似 2.0
		对于两首歌，如果喜欢听的人群都是差不多的，那侧面就可以反映出，这两首歌比较相似
		参见 05.vector_song-user.jpg，跟基于相似用户推荐中的图几乎一样。只不过这里把歌曲和用户主次颠倒了一下
		针对每个歌曲，将每个用户的打分作为向量
		通过计算向量之间的欧几里得距离，来表示歌曲之间的相似度
			欧几里得距离越小，表示两个歌曲越相似
			在用户已经听过的歌曲中，找出他喜爱程度较高的歌曲
			找出跟这些歌曲相似度很高的其他歌曲，推荐给他

扩展
	音乐推荐系统是推荐系统（Recommendation System）里最典型的一类问题
		算法的强大之处，利用简单的向量空间的欧几里得距离，就能解决如此复杂的问题
	工程中遇到的问题还有很多
		冷启动问题
		产品初期积累的数据不多，不足以做推荐
		...

思考
	能想到推荐算法的其他应用场景吗？
*/
