package practical

/*
算法实战（五）：如何用学过的数据结构和算法实现一个短网址系统？

短网址服务，这样一个简单的功能，是如何实现的呢？底层都依赖了哪些数据结构和算法呢？

短网址服务整体介绍
	功能
		核心功能，是把原始的长网址转化成短网址
		另外一个必不可少的功能是，当用户点击短网址的时候，短网址服务会将浏览器重定向为原始网址
	过程是如何实现的呢？
		浏览器会先访问短网址服务，通过短网址获取到原始网址，再通过原始网址访问到页面
		示意图
			05.short_ip.jpg

如何通过哈希算法生成短网址？
	哈希算法
		可以将一个不管多长的字符串，转化成一个长度固定的哈希值
		不需要复杂的哈希算法，比如 MD5、SHA 等
		因为不需要考虑反向解密的难度，所以只需要关心哈希算法的计算速度和冲突概率
		满足这样要求的哈希算法有很多，其中比较著名并且应用广泛的一个哈希算法，那就是 MurmurHash 算法
	MurmurHash 算法
		https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C
		简介
			2008 年才被发明出来
			但现在它已经广泛应用到 Redis、MemCache、Cassandra、HBase、Lucene 等众多著名的软件中
		举例
			MurmurHash 算法提供了两种长度的哈希值，一种是 32bits，一种是 128bits
			为了让最终生成的短网址尽可能短，可以选择 32bits 的哈希值
			比如 https://github.com/wangzheng0822/ratelimiter4j 经过 MurmurHash 计算后，得到的哈希值就是 181338494
			最终的短网址 http://t.cn/181338494（其中，http://t.cn 是短网址服务的域名）
		特点
			计算速度快
			冲突的概率非常低
	1.如何让短网址更短？
	2.如何解决哈希冲突问题？
	3.如何优化哈希算法生成短网址的性能？
如何让短网址更短？
	在网址 URL 中，常用的合法字符有 0～9、a～z、A～Z 这样 62 个字符
	将 10 进制的哈希值转化成 62 进制
	计算过程
		05.short_ip_62.jpg
如何解决哈希冲突问题？
	存储
		一般情况下，会保存短网址跟原始网址之间的对应关系，以便后续用户在访问短网址的时候，可以根据对应关系，查找到原始网址
		存储方式可以是自己设计存储系统或者利用现成的数据库
			如数据库有 MySQL、Redis
			假设短网址与原始网址之间的对应关系，就存储在 MySQL 数据库中
	MySQL
		有一个新的原始网址需要生成短网址的时候，先利用 MurmurHash 算法，生成短网址
		然后，拿这个新生成的短网址，在 MySQL 数据库中查找
		1.如果没有找到相同的短网址，这也就表明，这个新生成的短网址没有冲突
			将这个短网址返回给用户（请求生成短网址的用户），然后将这个短网址与原始网址之间的对应关系，存储到 MySQL 数据库中
		2.如果在数据库中，找到了相同的短网址，那也并不一定说明就冲突了
			a)已如果数据库中的原始网址，跟现在正在处理的原始网址是一样的，这就说明已经有人请求过这个原始网址的短网址了
				拿这个短网址直接用
			b)如果数据库中记录的原始网址，跟正在处理的原始网址不一样，那就说明哈希算法发生了冲突
		解决冲突：
			可以给原始网址拼接一串特殊字符，比如“[DUPLICATED]”，然后再重新计算哈希值，两次哈希计算都冲突的概率，显然是非常低的
			假设出现非常极端的情况，又发生冲突了，可以再换一个拼接字符串，比如“[OHMYGOD]”，再计算哈希值
			然后把计算得到的哈希值，跟原始网址拼接了特殊字符串之后的文本，一并存储在 MySQL 数据库中
		解决冲突后的查找
			当用户访问短网址的时候，短网址服务先通过短网址，在数据库中查找到对应的原始网址
			如果原始网址有拼接特殊字符（这个很容易通过字符串匹配算法找到），就先将特殊字符去掉
			然后再将不包含特殊字符的原始网址返回给浏览器
如何优化哈希算法生成短网址的性能？
	需求
		为了判断生成的短网址是否冲突，需要拿生成的短网址，在数据库中查找
		如果数据库中存储的数据非常多，那查找起来就会非常慢，势必影响短网址服务的性能
		那有没有什么优化的手段呢？
	索引
		对 MySQL 数据库，可以给短网址字段添加 B+ 树索引
	SQL 语句分析
		在短网址生成的过程中，会跟数据库打两次交道，也就是会执行两条 SQL 语句
		第一个 SQL 语句是通过短网址查询短网址与原始网址的对应关系
		第二个 SQL 语句是将新生成的短网址和原始网址之间的对应关系存储到数据库
		瓶颈：
		一般情况下，数据库和应用服务（只做计算不存储数据的业务逻辑部分）会部署在两个独立的服务器或者虚拟服务器上
		那两条 SQL 语句的执行就需要两次网络通信
		IO 通信耗时以及 SQL 语句的执行，才是整个短网址服务的性能瓶颈所在
	如何减少 SQL 语句呢？
		方案一：给数据库中的短网址字段，添加一个唯一索引（不只是索引，还要求表中不能有重复的数据）
			当有新的原始网址需要生成短网址的时候，并不会先拿生成的短网址，在数据库中查找判重，而是直接将生成的短网址与对应的原始网址，尝试存储到数据库中
			如果数据库能够将数据正常写入，那说明并没有违反唯一索引，也就是说，这个新生成的短网址并没有冲突
			如果数据库反馈违反唯一性索引异常，那还得重新执行刚刚讲过的“查询、写入”过程，SQL 语句执行的次数不减反增
				在大部分情况下，把新生成的短网址和对应的原始网址，插入到数据库的时候，并不会出现冲突
				所以，大部分情况下，只需要执行一条写入的 SQL 语句就可以了
				从整体上看，总的 SQL 语句执行次数会大大减少
		方案二：布隆过滤器
			当有新的短网址生成的时候，先拿这个新生成的短网址，在布隆过滤器中查找
			如果查找的结果是不存在，那就说明这个新生成的短网址并没有冲突
				此时，只需要再执行写入短网址和对应原始网页的 SQL 语句就可以了
			通过先查询布隆过滤器，总的 SQL 语句的执行次数减少了

如何通过 ID 生成器生成短网址？
	思路
		维护一个 ID 自增生成器，它可以生成 1、2、3…这样自增的整数 ID
		当短网址服务接收到一个原始网址转化成短网址的请求之后，它先从 ID 生成器中取一个号码
		然后将其转化成 62 进制表示法，拼接到短网址服务的域名（比如http://t.cn/）后面，就形成了最终的短网址
		最后，把生成的短网址和对应的原始网址存储到数据库中
	细节
		1.相同的原始网址可能会对应不同的短网址
		2.如何实现高性能的 ID 生成器？
相同的原始网址可能会对应不同的短网址
	需求
		每次新来一个原始网址，就生成一个新的短网址，这种做法就会导致两个相同的原始网址生成了不同的短网址
		这个该如何处理呢？
	两种处理思路
		方案一：不处理
			相同的原始网址对应不同的短网址，这个用户是可以接受的
			在大部分短网址的应用场景里，用户只关心短网址能否正确地跳转到原始网址
			至于短网址长什么样子，他其实根本就不关心
			所以，即便是同一个原始网址，两次生成的短网址不一样，也并不会影响到用户的使用
		方案二：借助哈希算法生成短网址的处理思想
			当要给一个原始网址生成短网址的时候，要先拿原始网址在数据库中查找，看数据库中是否已经存在相同的原始网址了
			如果数据库中存在，那就取出对应的短网址，直接返回给用户
			处理：
				需要给数据库中的短网址和原始网址这两个字段，都添加索引
				短网址上加索引是为了提高用户查询短网址对应的原始网页的速度
				原始网址上加索引是为了加快上面的通过原始网址查询短网址的速度
			代价：
				一方面两个索引会占用更多的存储空间
				另一方面索引还会导致插入、删除等操作性能的下降
如何实现高性能的 ID 生成器？
	方案举例
		利用数据库自增字段
		自己维护一个计数器，不停地加一加一
		但是，一个计数器来应对频繁的短网址生成请求，显然是有点吃力的
		因为计数器必须保证生成的 ID 不重复，笼统概念上讲，就是需要加锁
	其他思路
		思路一：借助 03.disruptor.go
			给 ID 生成器装多个前置发号器，批量地给每个前置发号器发送 ID 号码
			当接受到短网址生成请求的时候，就选择一个前置发号器来取号码
			这样通过多个前置发号器，明显提高了并发发号的能力
			示意图
				05.short_ip_id-1.jpg
		思路二：类似思路一
			直接实现多个 ID 生成器同时服务
			为了保证每个 ID 生成器生成的 ID 不重复。要求每个 ID 生成器按照一定的规则，来生成 ID 号码
			比如，第一个 ID 生成器只能生成尾号为 0 的，第二个只能生成尾号为 1 的，以此类推
			这样通过多个 ID 生成器同时工作，也提高了 ID 生成的效率
			示意图
				05.short_ip_id-2.jpg

总结
	利用哈希算法来生成短网址的思路
		实际上，已经完全满足需求了，已经可以直接用到真实的软件开发中
	通过 ID 生成器来生成短网址
		同样转成 62 进制表示法，也可以用到真实的软件开发中

思考
	1.如果还要额外支持用户自定义短网址功能（http//t.cn/{用户自定部分}），又该如何改造上面的算法呢?
	2.通过 ID 生成器生成短网址这种实现思路，相同的原始网址可能会对应不同的短网址。针对这个问题，其中一个解决思路就是，不做处理
	但是，如果每个请求都生成一个短网址，并且存储在数据库中，那这样会不会撑爆数据库呢？又该如何解决呢？
		王争：分库分表存储，或者用一些大型 key-value 数据库
	// TODO
*/
