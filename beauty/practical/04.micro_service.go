package practical

/*
算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法

微服务
	把复杂的大应用，解耦拆分成几个小的应用
	好处
		有利于团队组织架构的拆分，毕竟团队越大协作的难度越大
		每个应用都可以独立运维，独立扩容，独立上线，各个应用之间互不影响
		不用像原来那样，一个小功能上线，整个大应用都要重新发布
	弊端
		服务之间的调用关系变得更复杂，平台的整体复杂熵升高，出错的概率、debug 问题的难度都高了好几个数量级
	服务治理便成了微服务的一个技术重点
		服务治理涉及的内容比较多，比如鉴权、限流、降级、熔断、监控告警等等
		这些服务治理功能的实现，底层依赖大量的数据结构和算法

鉴权
	背景
		假设有一个微服务叫用户服务（User Service）
		它提供很多用户相关的接口，比如获取用户信息、注册、登录等，给公司内部的其他应用使用
		并不是公司内部所有应用，都可以访问这个用户服务
		也并不是每个有访问权限的应用，都可以访问用户服务的所有接口
		示例：
			04.micro_service_route_demo.jpg
	实现接口鉴权功能的思路
		事先将应用对接口的访问权限规则设置好
		当某个应用访问其中一个接口的时候，就可以拿应用的请求 URL，在规则中进行匹配
			如果匹配成功，就说明允许访问
			如果没有可以匹配的规则，那就说明这个应用没有这个接口的访问权限，就拒绝服务
如何实现快速鉴权？
	接口的格式举例：不同接口的鉴权实现方式是类似的
		类似 Dubbo 这样的 RPC 接口
		类似 Spring Cloud 这样的 HTTP 接口
	HTTP 接口的鉴权实现，具体到实现层面，该用什么数据结构来存储规则呢？用户请求 URL 在规则中快速匹配，又该用什么样的算法呢？
		细化为三个更加详细的需求：
		1.如何实现精确匹配规则？
		2.如何实现前缀匹配规则？
		3.如何实现模糊匹配规则？
1.如何实现精确匹配规则？
	只有当请求 URL 跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理
		04.micro_service_route_match-1.jpg
	匹配规则：
		散列表：
			不同的应用对应不同的规则集合，使用散列表存储这种对应关系
		字符串数组：存储每个应用对应的权限规则
			当用户请求到来时，拿用户的请求 URL，在这个字符串数组中逐一匹配，匹配的算法是字符串匹配算法（比如 KMP、BM、BF 等）
			因为规则不会经常变动
			为了加快匹配速度，可以按照字符串的大小给规则排序，把它组织成有序数组这种数据结构
			当要查找某个 URL 能否匹配其中某条规则的时候，可以采用二分查找算法，在有序数组中进行匹配
			对于规则中接口长度比较长，并且鉴权功能调用量非常大的情况，这种优化方法带来的性能提升还是非常可观的
2.如何实现前缀匹配规则？
	只要某条规则可以匹配请求 URL 的前缀，就可以说这条规则能够跟这个请求 URL 匹配
		04.micro_service_route_match-2
	匹配规则：
		散列表：
			不同的应用对应不同的规则集合，使用散列表存储这种对应关系
		Trie树：非常适合用来做前缀匹配，存储每个应用对应的权限规则
			每个节点不是存储单个字符，而是存储接口被“/”分割之后的子目录（比如“/user/name”被分割为“user”“name”两个子目录）
			因为规则并不会经常变动
			可以把每个节点的子节点们，组织成有序数组这种数据结构
			在匹配的过程中，可以利用二分查找算法，决定从一个节点应该跳到哪一个子节点
3.如何实现模糊匹配规则？
	规则中包含通配符，比如“**”表示匹配任意多个子目录，“*”表示匹配任意一个子目录
	只要用户请求 URL 可以跟某条规则模糊匹配，就可以说这条规则适用于这个请求
		04.micro_service_route_match-3.jpg
	匹配规则：
		散列表：
			不同的应用对应不同的规则集合，使用散列表存储这种对应关系
		回溯 + 正则表达式：
			采用回溯算法，拿请求 URL 跟每条规则逐一进行模糊匹配
			时间复杂度是非常高
		优化思路
			挖掘出隐形的条件，并不是每条规则都包含通配符，包含通配符的只是少数
			可以把不包含通配符的规则和包含通配符的规则分开处理
		不含通配符：组织成有序数组或者 Trie 树（具体组织成什么结构，视具体的需求而定）
			有序数组：精确匹配
			前缀匹配：Trie树
		含通配符
			简单存储在一个普通数组中
			回溯算法匹配，尽管匹配起来会比较慢，但是毕竟这种规则比较少
		匹配
			先在不包含通配符的有序数组或者 Trie 树中查找
			如果能够匹配，就不需要继续在通配符规则中匹配了
			如果不能匹配，就继续在通配符规则中查找匹配

限流
	背景
		所谓限流，顾名思义，就是对接口调用的频率进行限制
		比如每秒钟不能超过 100 次调用，超过之后，就拒绝服务
	应用场景
		秒杀、大促、双 11、618 等
		限流已经成为了保证系统平稳运行的一种标配的技术解决方案
	分类：按照不同的限流粒度，限流可以分为很多种类型
		比如给每个接口限制不同的访问频率
		或者给所有接口限制总的访问频率
			以下针对此情况分析
		又或者更细粒度地限制某个应用对某个接口的访问频率
		...
如何实现精准限流？
	固定时间窗口限流算法：最简单的限流算法
		思路
			首先需要选定一个时间起点，之后每当有接口请求到来，就将计数器加一
			如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次访问请求），出现累加访问次数超过限流值的情况时，就拒绝后续的访问请求
			当进入下一个时间窗口之后，计数器就清零重新计数
			示例：
				04.micro_service_sentinel-1.jpg
		缺点
			限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量
		举例
			假设限流规则是，每秒钟不能超过 100 次接口请求
			第一个 1s 时间窗口内，100 次接口请求都集中在最后 10ms 内
			在第二个 1s 的时间窗口内，100 次接口请求都集中在最开始的 10ms 内
			在两个时间窗口临界的 20ms 内，会集中有 200 次接口请求
			固定时间窗口限流算法并不能对这种情况做限制，所以，集中在这 20ms 内的 200 次请求就有可能压垮系统
	滑动时间窗口限流算法
		思路
			限制任意时间窗口（比如 1s）内，接口请求数都不能超过某个阈值（ 比如 100 次）
			流量经过滑动时间窗口限流算法整形之后，可以保证任意一个 1s 的时间窗口内，都不会超过最大允许的限流值
			从流量曲线上来看会更加平滑
		实现
			假设限流的规则是，在任意 1s 内，接口的请求次数都不能大于 K 次
			那就维护一个大小为 K+1 的循环队列，用来记录 1s 内到来的请求
			当有新的请求到来时，将与这个新请求的时间间隔超过 1s 的请求，从队列中删除
			再来看循环队列中是否有空闲位置
				如果有，则把新请求存储在队列尾部（tail 指针所指的位置）
				如果没有，则说明这 1 秒内的请求次数已经超过了限流值 K，所以这个请求被拒绝服务
			示例：
				04.micro_service_sentinel-2.jpg
		缺点
			可以保证任意时间窗口内，接口请求次数都不会超过最大限流值
			但是仍然不能防止，在细时间粒度上访问过于集中的问题
	小结
		基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口
		只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制
	更加平滑的限流算法
		令牌桶算法
		漏桶算法
		...
	王争开源的限流框架
		https://github.com/wangzheng0822/ratelimiter4j

思考
	1.除了用循环队列来实现滑动时间窗口限流算法之外，是否还可以用其他数据结构来实现呢？
		请对比一下这些数据结构跟循环队列在解决这个问题时的优劣之处
	2.分析一下鉴权那部分内容中，前缀匹配算法的时间复杂度和空间复杂度
*/
