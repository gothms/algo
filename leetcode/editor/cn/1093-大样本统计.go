//我们对 0 到 255 之间的整数进行采样，并将结果存储在数组 count 中：count[k] 就是整数 k 在样本中出现的次数。
//
// 计算以下统计数据:
//
//
// minimum ：样本中的最小元素。
// maximum ：样品中的最大元素。
// mean ：样本的平均值，计算为所有元素的总和除以元素总数。
// median ：
//
// 如果样本的元素个数是奇数，那么一旦样本排序后，中位数 median 就是中间的元素。
// 如果样本中有偶数个元素，那么中位数median 就是样本排序后中间两个元素的平均值。
//
// mode ：样本中出现次数最多的数字。保众数是 唯一 的。
//
//
// 以浮点数数组的形式返回样本的统计信息 [minimum, maximum, mean, median, mode] 。与真实答案误差在 10⁻⁵ 内的答案
//都可以通过。
//
//
//
// 示例 1：
//
//
//输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
//输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
//解释：用count表示的样本为[1,2,2,2,3,3,3,3]。
//最小值和最大值分别为1和3。
//均值是(1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375。
//因为样本的大小是偶数，所以中位数是中间两个元素2和3的平均值，也就是2.5。
//众数为3，因为它在样本中出现的次数最多。
//
// 示例 2：
//
//
//输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
//输出：[1.00000,4.00000,2.18182,2.00000,1.00000]
//解释：用count表示的样本为[1,1,1,1,2,2,3,3,3,4,4]。
//最小值为1，最大值为4。
//平均数是(1+1+1+1+2+2+2+3+3+4+4)/ 11 = 24 / 11 = 2.18181818…(为了显示，输出显示了整数2.18182)。
//因为样本的大小是奇数，所以中值是中间元素2。
//众数为1，因为它在样本中出现的次数最多。
//
//
//
//
// 提示：
//
//
// count.length == 256
// 0 <= count[i] <= 10⁹
// 1 <= sum(count) <= 10⁹
// count 的众数是 唯一 的
//
//
// Related Topics 数组 数学 概率与统计 👍 27 👎 0

package main

func main() {
	//fmt.Println(20.6 >> 1)
}

/*
思路：
	1.第一个出现的 count[i]>0 的数，为 minimum
		最后一个出现的 count[i]>0 的数，为 maximum
		mean 和 mode 计算方法也相对简单
	2.median 中位数
		2.1.元素总数为 cnt，那么中位数的排序位置可能是：
			(cnt/2 + cnt/2-1)/2：cnt为偶数
			cnt/2：cnt为奇数
		2.2.可以在遍历 count 的过程中，动态的保存当前元素总数，锁对应的中位数的排序位置（即索引）
			最后通过索引和元素总数的奇偶性，计算出中位数
		2.3.需要保存两个索引：mid midLast，其中 mid>midLast
			a)当元素总数是偶数，且 (cnt/2 + cnt/2-1)/2 中
				排序位置为 cnt/2 的中位数恰好是 mid 索引处的第一个元素时
				排序位置为 cnt/2-1 的中位数恰好是 midLast 索引处的最后一个元素时
				median = (count[mid]+count[midLast]) / 2
			b)当元素总数是奇数，且 cnt/2 排序位置的数恰好是 mid 索引处的第一个元素时
				median = count[midLast]
			c)其他情况时，median = count[mid]
	3.思考：有一组动态的数据，数值是随机的，元素个数是变化的，那么这些数的中位数也是随机的
		怎么用尽量小的时间复杂度，快速获取中位数呢？
*/
//leetcode submit region begin(Prohibit modification and deletion)
func sampleStats(count []int) []float64 {
	mid, midLast, mMore, min, max, cnt, sum, maxCnt :=
		0, 0, count[0], -1, 0, 0, 0, 0
	for i := 0; i < 256; i++ {
		if count[i] == 0 {
			continue
		}
		if min < 0 {
			min = i
		}
		max = i
		cnt += count[i]
		sum += i * count[i]
		if count[i] > count[maxCnt] {
			maxCnt = i
		}
		add := (count[i] + 1) >> 1 // 开始计算 中位数
		if count[i]&1 == 1 && cnt&1 == 0 {
			add-- // count[i] 连续奇数
		}
		mMore -= add
		for j := mid; mMore <= 0; mMore += count[j] {
			j++
			for j <= i && count[j] == 0 {
				j++
			}
			midLast, mid = mid, j
		}
	}
	median := float64(mid)
	if mMore == count[mid] { // 修正 中位数
		if cnt&1 == 0 {
			median = float64(midLast+mid) / 2.0
		} else {
			median = float64(midLast)
		}
	}
	return []float64{float64(min), float64(max),
		float64(sum) / float64(cnt), median, float64(maxCnt)}
}

//leetcode submit region end(Prohibit modification and deletion)
