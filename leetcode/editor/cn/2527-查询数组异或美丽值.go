//给你一个下标从 0 开始的整数数组 nums 。
//
// 三个下标 i ，j 和 k 的 有效值 定义为 ((nums[i] | nums[j]) & nums[k]) 。
//
// 一个数组的 异或美丽值 是数组中所有满足 0 <= i, j, k < n 的三元组 (i, j, k) 的 有效值 的异或结果。
//
// 请你返回 nums 的异或美丽值。
//
// 注意：
//
//
// val1 | val2 是 val1 和 val2 的按位或。
// val1 & val2 是 val1 和 val2 的按位与。
//
//
//
//
// 示例 1：
//
//
//输入：nums = [1,4]
//输出：5
//解释：
//三元组和它们对应的有效值如下：
//- (0,0,0) 有效值为 ((1 | 1) & 1) = 1
//- (0,0,1) 有效值为 ((1 | 1) & 4) = 0
//- (0,1,0) 有效值为 ((1 | 4) & 1) = 1
//- (0,1,1) 有效值为 ((1 | 4) & 4) = 4
//- (1,0,0) 有效值为 ((4 | 1) & 1) = 1
//- (1,0,1) 有效值为 ((4 | 1) & 4) = 4
//- (1,1,0) 有效值为 ((4 | 4) & 1) = 0
//- (1,1,1) 有效值为 ((4 | 4) & 4) = 4
//数组的异或美丽值为所有有效值的按位异或 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5 。
//
// 示例 2：
//
//
//输入：nums = [15,45,20,2,34,35,5,44,32,30]
//输出：34
//解释：数组的异或美丽值为 34 。
//
//
//
//
// 提示：
//
//
// 1 <= nums.length <= 10⁵
// 1 <= nums[i] <= 10⁹
//
//
// Related Topics 位运算 数组 数学 👍 29 👎 0

package main

import "fmt"

func main() {
	nums := []int{15, 45, 20, 2, 34, 35, 5, 44, 32, 30}
	beauty := xorBeauty(nums)
	fmt.Println(beauty)
}

/*
位运算经典技巧：由于每个比特位互不相干，所以拆分成每个比特位分别计算。
	由于只有 0 和 1，这样就好算了。
	对异或有影响的是 1，所以只需要统计 (a∣b)&c=1 的情况。
	那么 c 必须是 1，a 和 b 不能都是 0。

	设有 y 个 1，那么就有 x=n−y 个 0。
	那么 c 有 y 个，a∣b 有 n^2−x^2 个（任意选是 n^2，减去两个都是 0 的 x^2 个）。
	根据乘法原理，一共可以产生
	ones = (n^2−x^2)y = (n^2−(n−y)^2)y = (2ny−y^2)y 个 1。
	由于异或只在乎 ones 的奇偶性，所以 2ny 可以去掉，那么就变成看 y^3 的奇偶性，也就是 y 的奇偶性。
	如果 y 是奇数，那么这个比特位的异或值就是 1。
	这实际上就是看每个比特位的异或值是否为 1。
	那么把 nums 的每个数异或起来，就是答案。
*/

// leetcode submit region begin(Prohibit modification and deletion)
func xorBeauty(nums []int) int {
	ret := 0
	for _, v := range nums {
		ret ^= v
	}
	return ret
}

//leetcode submit region end(Prohibit modification and deletion)
