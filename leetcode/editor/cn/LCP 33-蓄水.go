//给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 `i` 个水缸配备的水桶容量记作 `bucket[i]`。小扣有以下两种操作：
//- 升级水桶：选择任意一个水桶，使其容量增加为 `bucket[i]+1`
//- 蓄水：将全部水桶接满水，倒入各自对应的水缸
//
//每个水缸对应最低蓄水量记作 `vat[i]`，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。
//
//注意：实际蓄水量 **达到或超过** 最低蓄水量，即完成蓄水要求。
//
//**示例 1：**
//
//> 输入：`bucket = [1,3], vat = [6,8]`
//>
//> 输出：`4`
//>
//> 解释：
//> 第 1 次操作升级 bucket[0]；
//> 第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。
//> ![vat1.gif](https://pic.leetcode-cn.com/1616122992-RkDxoL-vat1.gif)
//
//**示例 2：**
//
//> 输入：`bucket = [9,0,1], vat = [0,2,2]`
//>
//> 输出：`3`
//>
//> 解释：
//> 第 1 次操作均选择升级 bucket[1]
//> 第 2~3 次操作选择蓄水，即可完成蓄水要求。
//
//**提示：**
//- `1 <= bucket.length == vat.length <= 100`
//- `0 <= bucket[i], vat[i] <= 10^4`
//
// Related Topics 贪心 数组 堆（优先队列） 👍 88 👎 0

package main

import (
	"container/heap"
	"fmt"
)

func main() {
	bucket := []int{1, 3}
	vat := []int{6, 8}
	bucket = []int{0}
	vat = []int{0}
	//bucket = []int{3, 2, 5}
	//vat = []int{0, 0, 0}
	//bucket = []int{9, 0, 1}
	//vat = []int{0, 2, 2}
	//bucket = []int{16, 29, 42, 70, 42, 9}
	//vat = []int{89, 44, 50, 90, 94, 91} // 11
	// 127
	//bucket = []int{3710, 6067, 2993, 70, 2340, 2748, 9385, 3027, 3456, 5246, 9739, 1220, 9539, 9074, 4729, 7051, 8462, 6908, 3649, 9996, 8890, 2980, 4350, 7350, 6344, 6759, 4420, 269, 9341, 648, 7737, 8133, 3717, 2766, 5807, 4338, 2077, 5775, 4905, 7262, 1258, 613, 3837, 3475, 437, 3739, 9814, 4790, 2075, 7722, 3290, 5685, 3499, 6992, 4421, 934, 6004, 5763, 3463, 6138, 8818, 445, 4778, 4979, 126, 3969, 2994, 87, 3739, 8582, 9559, 8326, 9132, 257, 8928, 9147, 1615, 4665, 9828, 3925, 6435, 5326, 836, 519, 298, 600, 5503, 273, 9580, 5383, 8966, 4810, 1386, 7207, 8060, 678, 8837, 6946, 1210, 945}
	//vat = []int{6304, 6509, 4276, 9645, 6455, 8167, 9667, 4385, 8872, 7889, 9936, 4413, 9922, 9894, 8065, 7627, 9225, 9907, 7055, 9996, 9439, 3351, 9317, 8363, 9383, 6850, 4621, 5389, 9508, 3391, 9650, 8363, 8719, 5594, 8770, 5403, 7107, 9941, 9254, 9355, 4614, 4640, 4896, 8759, 4397, 8441, 9870, 9906, 2396, 8092, 6939, 9432, 8182, 9090, 8029, 4930, 7772, 7066, 7279, 7778, 9529, 2947, 6552, 6930, 5260, 8470, 8478, 1371, 9453, 9767, 9888, 9964, 9960, 3990, 9391, 9377, 3063, 5374, 9880, 7684, 7864, 7078, 2622, 3754, 617, 9773, 9415, 8026, 9883, 5735, 9233, 6715, 9105, 7932, 9178, 1081, 9340, 7284, 6621, 1965}
	// 138
	bucket = []int{9988, 5017, 5130, 2445, 9896, 9151, 3625, 7801, 608, 3283, 1386, 979, 5209, 4182, 8234, 9870, 8714, 6435, 3800, 956, 4006, 5620, 7474, 1205, 6993, 3320, 1201, 7593, 905, 3816, 4522, 4560, 8027, 8219, 6686, 3779, 2141, 1240, 6504, 6612, 6921, 7329, 8145, 5745, 7652, 4340, 7933, 6246, 5157, 9447, 107, 9665, 3653, 2978, 9832, 4945, 4312, 2199, 449, 8432, 3230, 8163, 800, 6547, 1110, 1194, 9384, 632, 3275, 1229, 7230, 8643, 7613, 8256, 5043, 1288, 3088, 8997, 4554, 4755, 7433, 8146, 9722, 3469, 8863, 5831, 7816, 5058, 4316, 7946, 8402, 975, 2450, 4958, 9811, 9336, 21, 9309, 8999, 56}
	vat = []int{9991, 6973, 7192, 9876, 9910, 9549, 3700, 8814, 1308, 9981, 9234, 7292, 7732, 8458, 8441, 9939, 9621, 7285, 7452, 2718, 6589, 7555, 8788, 3202, 7832, 4781, 8798, 9299, 2112, 9963, 8755, 7240, 9217, 8587, 6782, 9703, 8954, 3759, 6907, 7218, 7333, 8020, 8323, 5750, 9510, 8571, 8664, 8510, 9363, 9741, 8643, 9825, 4227, 8530, 9961, 8511, 8949, 7486, 9086, 9690, 5316, 9581, 9314, 8817, 7234, 8998, 9485, 5394, 7365, 1501, 7984, 9802, 9778, 8314, 7482, 7117, 5117, 9609, 8732, 9728, 9330, 8800, 9775, 6210, 8966, 7700, 8802, 7607, 8950, 9730, 9855, 1231, 5228, 5329, 9982, 9532, 3230, 9951, 9034, 8299}
	cnt := storeWater(bucket, vat)
	fmt.Println(cnt)

	//n := 8299
	//x := 56
	//for i := 0; i < 50; i++ {
	//	y := float64(n)/float64(x+i) + float64(i)
	//	fmt.Println(i, y)
	//}
	//
	//fmt.Println(math.Floor(5.000))
	//fmt.Println(math.Ceil(5.000))
	//fmt.Println(math.Ceil(5.001))
}

/*
思路：堆
	1.设第 i 个水桶，满足第 i 个水缸蓄水量，需要装水 b[i]/vat[i] = cnt[i] 次
		那么，总装水次数即为 cnt[i]，即装水次数只受限于 当前最大cnt[i]
			举例：b=[8,1,3,5] vat=[8,4,7,9]
			那么：cnt=[1,4,3,2]
			即索引为 1 时，b=1 vat=4 时，需要装 4 次水，每个b[i]都能满足每个vat[i]
		但是当 b=1 增加容量为 b=2 时，b=2 vat=4 需要装水 2 次
			而索引为 2 的情况是，b=3 vat=7 需要 3 次
			即，此时需要装水 3 次，才能使每个b[i]都能满足每个vat[i]
		那么使用什么数据结构来动态获取 当前最大装水次数？
	2.上面这个例子就是用来说明，采用 大顶堆，实现一个 优先队列 来动态获取 当前最大装水次数
		将 b[i] vat[i] 的每对值，存入堆，vat[i]/b[i] 的值，即为 b[i] vat[i] 需要的装水次数 cnt[i]
			则，将 vat[i]/b[i] 最大值，作为堆顶元素 heap[0]
			当然，也可以存 vat[i]/b[i] i，这样在堆化时，就不用再计算 vat[i]/b[i]
		每次对 heap[0] 中 b[i] 进行容量升级 b[i]=b[i]+1
			再对 vat[i]/(b[i]+1) 做堆化，如此往复这个过程
			那么如何判断，何时 heap[0] 不继续这个过程，能满足题意所求呢？
	3.假设 heap[0] 当前的值为 b[i] vat[i]
		简单说就是，当 vat[i]/b[i] < vat[i]/(b[i]+1) + 1 时，即可停止（这里都先不考虑 =）
		为什么呢？
			设 vat[i]=n，b[i]=x，b[i] 升级了 a 次为 b[i]+a
			那么 n/(x+a) + a 即为 b[i] 升级 a 次后，一共的操作次数（装水次数+升级次数）
			简化为 n/(x+a) + (x+a) - a
			可知 x+a = 根号n 时，n/(x+a) + a 取得最小值
		当升级次数 小于a 或 大于a 时，都有 vat[i]/b[i] > vat[i]/(b[i]+1) + 1
坑：
	1.思路3.中，计算 vat[i]/b[i] 的值如果取整数，那么会精度丢失，那么继续堆化的条件为：
		整数时：vat[i]/b[i] >= vat[i]/(b[i]+1) + 1
		浮点数时：vat[i]/b[i] > vat[i]/(b[i]+1) + 1
			整数取值的缺点是，堆化的次数会增多
	2.vat[i]/b[i] 取整数，且余数为 0 时
		两种写法：
			(vat[i]-1)/b[i] + 1：缺点是 vat[i]=0 出现 bug
			(vat[i]+b[i]-1)/b[i]
	3.考虑 b[i] = 0 的情况：先升级，b[i]=1
		考虑 vat[i] = 0 的情况：该对数据作废
	4.坑1.中，是对 b[i] 做 +1 处理的思路，还可以考虑对 vat[i]/b[i] 做 +1 处理的思路
		即保证升级 b[i] 后，该水缸的装水次数至少 -1
		那么两种方式有什么优劣？为什么说采用 b[i]+1 更好呢？请结合思路3.分析
*/
//leetcode submit region begin(Prohibit modification and deletion)
func storeWater(bucket []int, vat []int) int {
	minVal := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}
	h, cnt, n := pairHeap{}, 0, len(bucket)
	for i := 0; i < n; i++ {
		if bucket[i] == 0 {
			cnt++
			bucket[i] = 1
			//heap.Push(&h, [2]int{1, vat[i]})	// 避免 [0] [0] 情况
		}
		if vat[i] > 0 {
			heap.Push(&h, [2]int{bucket[i], vat[i]})
		}
	}
	if h.Len() == 0 {
		return 0
	}
	min := cnt + (h[0][1]-1)/h[0][0] + 1 // 初始化 min，防止不进循环
	//for (h[0][1]-1)/h[0][0] >= (h[0][1]-1)/(h[0][0]+1)+1 { // 写法一：堆化次数更多
	for float64(h[0][1])/float64(h[0][0]) > float64(h[0][1])/float64(h[0][0]+1)+1 { // 写法二
		cnt++
		h[0][0]++ // 需要在堆化之前
		heap.Fix(&h, 0)
		min = minVal(min, cnt+(h[0][1]-1)/h[0][0]+1) // 必须实时记录，且在堆化之后
	}
	return min
}

//type pair struct {
//	quotient float64
//	i        int
//}
//type pairHeap []pair
//
//func (h pairHeap) Len() int {
//	return len(h)
//}
//func (h pairHeap) Less(i, j int) bool {
//	return h[i].quotient > h[j].quotient
//}
//func (h pairHeap) Swap(i, j int) {
//	h[i], h[j] = h[j], h[i]
//}
//func (h *pairHeap) Push(x interface{}) {
//	*h = append(*h, x.(pair))
//}
//func (h *pairHeap) Pop() interface{} {
//	x := (*h)[len(*h)-1]
//	*h = (*h)[:len(*h)-1]
//	return x
//}

type pairHeap [][2]int

func (h pairHeap) Len() int {
	return len(h)
}
func (h pairHeap) Less(i, j int) bool {
	// 保持精度
	return float64(h[i][1])/float64(h[i][0]) > float64(h[j][1])/float64(h[j][0])
}
func (h pairHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}
func (h *pairHeap) Push(x interface{}) {
	*h = append(*h, x.([2]int))
}
func (h *pairHeap) Pop() interface{} {
	x := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return x
}

//leetcode submit region end(Prohibit modification and deletion)
