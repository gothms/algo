//小扣在秋日市集入口处发现了一个数字游戏。主办方共有 `N` 个计数器，计数器编号为 `0 ~ N-1`。每个计数器上分别显示了一个数字，小扣按计数器编号升序
//将所显示的数字记于数组 `nums`。每个计数器上有两个按钮，分别可以实现将显示数字加一或减一。小扣每一次操作可以选择一个计数器，按下加一或减一按钮。
//
//主办方请小扣回答出一个长度为 `N` 的数组，第 `i` 个元素(0 <= i < N)表示将 `0~i` 号计数器 **初始** 所示数字操作成满足所有条
//件 `nums[a]+1 == nums[a+1],(0 <= a < i)` 的最小操作数。回答正确方可进入秋日市集。
//
//由于答案可能很大，请将每个最小操作数对 `1,000,000,007` 取余。
//
//**示例 1：**
//
//> 输入：`nums = [3,4,5,1,6,7]`
//>
//> 输出：`[0,0,0,5,6,7]`
//>
//> 解释：
//> i = 0，[3] 无需操作
//> i = 1，[3,4] 无需操作；
//> i = 2，[3,4,5] 无需操作；
//> i = 3，将 [3,4,5,1] 操作成 [3,4,5,6], 最少 5 次操作；
//> i = 4，将 [3,4,5,1,6] 操作成 [3,4,5,6,7], 最少 6 次操作；
//> i = 5，将 [3,4,5,1,6,7] 操作成 [3,4,5,6,7,8]，最少 7 次操作；
//> 返回 [0,0,0,5,6,7]。
//
//**示例 2：**
//
//> 输入：`nums = [1,2,3,4,5]`
//>
//> 输出：`[0,0,0,0,0]`
//>
//> 解释：对于任意计数器编号 i 都无需操作。
//
//**示例 3：**
//
//> 输入：`nums = [1,1,1,2,3,4]`
//>
//> 输出：`[0,1,2,3,3,3]`
//>
//> 解释：
//> i = 0，无需操作；
//> i = 1，将 [1,1] 操作成 [1,2] 或 [0,1] 最少 1 次操作；
//> i = 2，将 [1,1,1] 操作成 [1,2,3] 或 [0,1,2]，最少 2 次操作；
//> i = 3，将 [1,1,1,2] 操作成 [1,2,3,4] 或 [0,1,2,3]，最少 3 次操作；
//> i = 4，将 [1,1,1,2,3] 操作成 [-1,0,1,2,3]，最少 3 次操作；
//> i = 5，将 [1,1,1,2,3,4] 操作成 [-1,0,1,2,3,4]，最少 3 次操作；
//> 返回 [0,1,2,3,3,3]。
//
//**提示：**
//- `1 <= nums.length <= 10^5`
//- `1 <= nums[i] <= 10^3`
//
// Related Topics 数组 数学 堆（优先队列） 👍 28 👎 0

package main

import (
	"container/heap"
	"fmt"
	"sort"
)

func main() {
	nums := []int{471, 626, 848, 957, 788, 138, 982, 721, 729, 956, 432, 1000, 478, 353, 586, 544, 304, 811, 359, 535, 992, 684, 606, 39, 384, 799, 120, 608, 540, 914, 19, 62, 410, 711, 449, 370, 263, 890, 124, 516, 861, 936, 729, 595, 768, 929, 649, 803, 65, 692, 548, 620, 871, 785, 15, 629, 251, 764, 973, 484, 172, 923, 859, 29, 297, 215, 436, 74, 762, 885, 272, 504, 307, 998, 83, 329, 520, 889, 584, 496, 443, 802, 180, 322, 640, 290, 292, 403, 11, 230, 743, 183, 600, 741, 558, 780, 970, 777, 288}
	game := numsGame(nums) // [0,154,375,704,704,1355,1547,1617,1617,1843,2142,2410,2665,3046,3188,3373,3710,3879,4163,4272,4619,4657,4698,5307,5531,5721,6211,6214,6283,6587,7179,7729,7923,8029,8186,8423,8725,9049,9492,9544,9836,10202,10317,10337,10489,10801,10823,10998,11562,11624,11707,11719,11957,12108,12728,12735,13114,13247,13581,13737,14199,14487,14703,15318,15659,16083,16285,16850,16972,17216,17586,17725,18059,18415,18975,19290,19398,19658,19704,19839,20005,20197,20628,20918,20945,21269,21579,21779,22368,22739,22880,23300,23300,23440,23484,23661,24023,24191,24513]
	fmt.Println(game)
}

// leetcode submit region begin(Prohibit modification and deletion)
func numsGame(nums []int) []int {
	// 中位数
	const mod int64 = 1_000_000_007
	ret, hMax, hMin := make([]int, len(nums)), &nGHP{}, &nGHP{}
	var maxSum, minSum int64
	for i, val := range nums {
		v := val - i
		if l := hMin.Len(); l == 0 || v >= hMin.IntSlice[0] { // 优先小顶堆
			heap.Push(hMin, v)
			minSum += int64(v)
			if l > hMax.Len() { // 调整
				t := heap.Pop(hMin).(int)
				minSum -= int64(t)
				maxSum += int64(t)
				heap.Push(hMax, -t)
			}
		} else { // 大顶堆
			heap.Push(hMax, -v) // push 负值
			maxSum += int64(v)
			if hMax.Len() > l {
				t := -heap.Pop(hMax).(int)
				maxSum -= int64(t)
				minSum += int64(t)
				heap.Push(hMin, t)
			}
		}
		if i&1 == 0 { // 操作次数的算法
			ret[i] = int((minSum - maxSum - int64(hMin.IntSlice[0])) % mod)
		} else {
			ret[i] = int((minSum - maxSum) % mod)
		}
	}
	return ret
}

type nGHP struct {
	sort.IntSlice
}

func (n *nGHP) Push(x any) {
	n.IntSlice = append(n.IntSlice, x.(int))
}

func (n *nGHP) Pop() any {
	v := n.IntSlice[len(n.IntSlice)-1]
	n.IntSlice = n.IntSlice[:len(n.IntSlice)-1]
	return v
}

//leetcode submit region end(Prohibit modification and deletion)
