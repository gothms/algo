//ç»™ä½ ä¸€æ£µæ ¹ä¸º root çš„äºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›žäºŒå‰æ ‘ä¸­å¥½èŠ‚ç‚¹çš„æ•°ç›®ã€‚
//
// ã€Œå¥½èŠ‚ç‚¹ã€X å®šä¹‰ä¸ºï¼šä»Žæ ¹åˆ°è¯¥èŠ‚ç‚¹ X æ‰€ç»è¿‡çš„èŠ‚ç‚¹ä¸­ï¼Œæ²¡æœ‰ä»»ä½•èŠ‚ç‚¹çš„å€¼å¤§äºŽ X çš„å€¼ã€‚
//
//
//
// ç¤ºä¾‹ 1ï¼š
//
//
//
// è¾“å…¥ï¼šroot = [3,1,4,3,null,1,5]
//è¾“å‡ºï¼š4
//è§£é‡Šï¼šå›¾ä¸­è“è‰²èŠ‚ç‚¹ä¸ºå¥½èŠ‚ç‚¹ã€‚
//æ ¹èŠ‚ç‚¹ (3) æ°¸è¿œæ˜¯ä¸ªå¥½èŠ‚ç‚¹ã€‚
//èŠ‚ç‚¹ 4 -> (3,4) æ˜¯è·¯å¾„ä¸­çš„æœ€å¤§å€¼ã€‚
//èŠ‚ç‚¹ 5 -> (3,4,5) æ˜¯è·¯å¾„ä¸­çš„æœ€å¤§å€¼ã€‚
//èŠ‚ç‚¹ 3 -> (3,1,3) æ˜¯è·¯å¾„ä¸­çš„æœ€å¤§å€¼ã€‚
//
// ç¤ºä¾‹ 2ï¼š
//
//
//
// è¾“å…¥ï¼šroot = [3,3,null,4,2]
//è¾“å‡ºï¼š3
//è§£é‡Šï¼šèŠ‚ç‚¹ 2 -> (3, 3, 2) ä¸æ˜¯å¥½èŠ‚ç‚¹ï¼Œå› ä¸º "3" æ¯”å®ƒå¤§ã€‚
//
// ç¤ºä¾‹ 3ï¼š
//
// è¾“å…¥ï¼šroot = [1]
//è¾“å‡ºï¼š1
//è§£é‡Šï¼šæ ¹èŠ‚ç‚¹æ˜¯å¥½èŠ‚ç‚¹ã€‚
//
//
//
// æç¤ºï¼š
//
//
// äºŒå‰æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®èŒƒå›´æ˜¯ [1, 10^5] ã€‚
// æ¯ä¸ªèŠ‚ç‚¹æƒå€¼çš„èŒƒå›´æ˜¯ [-10^4, 10^4] ã€‚
//
//
// Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘ ðŸ‘ 90 ðŸ‘Ž 0

package main

import "math"

func main() {

}

//leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode


 *     Right *TreeNode
 * }
 */
/*
æ€è·¯ï¼šdfs
	1.ç¿»è¯‘ä¸‹å¥½èŠ‚ç‚¹ï¼šå½“æŸä¸ªèŠ‚ç‚¹ï¼Œå¤§äºŽç­‰äºŽè·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯å¥½èŠ‚ç‚¹
	2.dfs
		2.1.ç»ˆæ­¢æ¡ä»¶
			å½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œè¿”å›ž0
		2.2.å½“å‰èŠ‚ç‚¹ root.Val >= è·¯å¾„èŠ‚ç‚¹æœ€å¤§å€¼ v
			v = root.Valï¼Œå¥½èŠ‚ç‚¹æ•° +1
		2.3.dfs ä¸‹æŽ¢
			dfs(r.Left, v) + dfs(r.Right, v)
*/
func goodNodes(root *TreeNode) int {
	// dfs
	var dfs func(*TreeNode, int) int
	dfs = func(r *TreeNode, v int) int {
		if r == nil {
			return 0
		}
		if r.Val < v {
			return dfs(r.Left, v) + dfs(r.Right, v)
		}
		return 1 + dfs(r.Left, r.Val) + dfs(r.Right, r.Val)
	}
	return dfs(root, math.MinInt32)
}

//leetcode submit region end(Prohibit modification and deletion)
