//给你一个长度为 n 、下标从 1 开始的二进制字符串，所有位最开始都是 0 。我们会按步翻转该二进制字符串的所有位（即，将 0 变为 1）。
//
// 给你一个下标从 1 开始的整数数组 flips ，其中 flips[i] 表示对应下标 i 的位将会在第 i 步翻转。
//
// 二进制字符串 前缀一致 需满足：在第 i 步之后，在 闭 区间 [1, i] 内的所有位都是 1 ，而其他位都是 0 。
//
// 返回二进制字符串在翻转过程中 前缀一致 的次数。
//
//
//
// 示例 1：
//
//
//输入：flips = [3,2,4,1,5]
//输出：2
//解释：二进制字符串最开始是 "00000" 。
//执行第 1 步：字符串变为 "00100" ，不属于前缀一致的情况。
//执行第 2 步：字符串变为 "01100" ，不属于前缀一致的情况。
//执行第 3 步：字符串变为 "01110" ，不属于前缀一致的情况。
//执行第 4 步：字符串变为 "11110" ，属于前缀一致的情况。
//执行第 5 步：字符串变为 "11111" ，属于前缀一致的情况。
//在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。
//
//
// 示例 2：
//
//
//输入：flips = [4,1,2,3]
//输出：1
//解释：二进制字符串最开始是 "0000" 。
//执行第 1 步：字符串变为 "0001" ，不属于前缀一致的情况。
//执行第 2 步：字符串变为 "1001" ，不属于前缀一致的情况。
//执行第 3 步：字符串变为 "1101" ，不属于前缀一致的情况。
//执行第 4 步：字符串变为 "1111" ，属于前缀一致的情况。
//在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。
//
//
//
// 提示：
//
//
// n == flips.length
// 1 <= n <= 5 * 10⁴
// flips 是范围 [1, n] 中所有整数构成的一个排列
//
//
// Related Topics 数组 👍 58 👎 0

package main

import "fmt"

func main() {
	// 5
	flips := []int{1, 2, 29, 4, 5, 6, 7, 8, 9, 23, 11, 66, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 10, 24, 60, 26, 27, 28, 3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 83, 53, 81, 55, 56, 57, 58, 59, 62, 61, 25, 63, 64, 65, 12, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 54, 82, 52, 84, 85}
	flips = []int{3, 2, 4, 1, 5}
	fmt.Println(len(flips))
	blue := numTimesAllBlue(flips)
	fmt.Println(blue)
}

/*
思路：位运算
	1.如果 flips.length <= 32，则可以用 位运算
		第一位记录 1，...，第32位记录 32
	2.位运算
		pre：记录当前已访问过的整数，记为 0
		ok：标记 [1,i] 的前缀都为 1
		如果 pre&ok == 0，则 [1,i] 前缀一致都为 1
思路：数组 O(n)空间
	1.开辟一个 bool 数组 cache，记录 [1,n] 之间已经被访问过的整数
		cache[0] 作为无效元素，为了方便计算，从 cache[1] 开始记录
	2.索引 j 记录 cache 中，[1,j) 前缀一致
		如果 j-1 > i，说明 [1,i] 前缀一致，cnt + 1
		cache[n+1] 作为哨兵，则不用判断 j<=n
思路：双指针 O(1)空间
	1.在 数组 方案的思路之上，寻求 O(1) 的空间复杂度
	2.为了标识 [1,n] 之间，哪些整数已经被访问过，将已被访问的整数置为 负数
		2.1.如 flips[i] = v，则 flips[v-1] = -flips[v-1]
			-1 是为了防止越界
			注意，v 这里是正数，编码时还要考虑 v 是负数的情况
		2.2.通过上面处理后，就可以通过判断 flips[j] < 0，来移动 j 了
思路：最大值
	1.由于 flips[i] 与 [1,n] 的值一一映射
	2.则当 [1,i] 前缀一致时，当前出现的最大值 flips[i]=max，一定有 max==i+1
*/
// leetcode submit region begin(Prohibit modification and deletion)
func numTimesAllBlue(flips []int) int {
	// 最大值
	cnt, max, n := 1, 0, len(flips)-1
	for i := 0; i < n; i++ {
		if flips[i] > max {
			max = flips[i]
		}
		if max == i+1 {
			cnt++
		}
	}
	return cnt

	// 双指针：O(1) 空间
	//abs := func(a int) int {
	//	if a < 0 {
	//		return -a
	//	}
	//	return a
	//}
	//cnt, n := 1, len(flips)-1 // 哨兵 n-1
	//for i, j := 0, 0; i < n; i++ {
	//	v := abs(flips[i]) - 1 // -1 避免越界
	//	flips[v] = -flips[v]   // 置为负值，方便 j 往后遍历
	//	if j == v {
	//		for j++; flips[j] < 0; j++ {
	//		}
	//	}
	//	if j > i {
	//		cnt++
	//	}
	//}
	//return cnt

	// 数组：O(n)
	//cnt, n := 0, len(flips)
	//cache := make([]bool, n+2) // 哨兵：不用判断 j<=n
	//for i, j := 0, 1; i < n; i++ {
	//	cache[flips[i]] = true
	//	if j == flips[i] {
	//		for j++; cache[j]; j++ {
	//		} // [1,j] 前缀一致
	//	}
	//	if j-1 > i { // [1,i] 前缀一致
	//		cnt++
	//	}
	//}
	//return cnt

	// 位运算：越界
	//cnt, n := 0, len(flips)
	//for i, pre, ok := 0, 1<<n-1, 1<<(n-1); i < n; i++ {
	//	if pre &^= 1 << (n - flips[i]); pre&ok == 0 {
	//		cnt++
	//	}
	//	ok |= ok >> 1
	//}
	//return cnt
}

//leetcode submit region end(Prohibit modification and deletion)
