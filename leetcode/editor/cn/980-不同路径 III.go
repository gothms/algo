//在二维网格 grid 上，有 4 种类型的方格：
//
//
// 1 表示起始方格。且只有一个起始方格。
// 2 表示结束方格，且只有一个结束方格。
// 0 表示我们可以走过的空方格。
// -1 表示我们无法跨越的障碍。
//
//
// 返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。
//
// 每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。
//
//
//
// 示例 1：
//
// 输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
//输出：2
//解释：我们有以下两条路径：
//1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
//2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
//
// 示例 2：
//
// 输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
//输出：4
//解释：我们有以下四条路径：
//1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
//2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
//3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
//4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
//
// 示例 3：
//
// 输入：[[0,1],[2,0]]
//输出：0
//解释：
//没有一条路能完全穿过每一个空的方格一次。
//请注意，起始和结束方格可以位于网格中的任意位置。
//
//
//
//
// 提示：
//
//
// 1 <= grid.length * grid[0].length <= 20
//
//
// Related Topics 位运算 数组 回溯 矩阵 👍 240 👎 0

package main

func main() {

}

/*
思路：回溯
	1.首先需要找出能走的点 [i,j] 的个数，以及起点的位置
		然后我们遍历所有可以走的点，当走到终点位置，且走遍了所有点时，代表找到一条路径
	2.标记走过的点
		由条件 1 <= grid.length * grid[0].length <= 20
		可知，使用 int32 可以表示所有需要走的点，则使用位运算来标记哪些点可走，哪些点不可走
		当前位置是 [i,j]，判断它的的四连通方向索引合法，且位运算标记可走时，就往这个方向走
	3.回溯
		终止条件：grid[i][j] == 2，此时若走完了所有点，则返回 1，表示找到一条路
		回溯：四连通方向都需要判断是否可走，以寻求所有可能的路径
*/
// leetcode submit region begin(Prohibit modification and deletion)
func uniquePathsIII(grid [][]int) int {
	// 回溯
	si, sj, point, r, c := 0, 0, 0, len(grid), len(grid[0])
	d := [5]int{0, -1, 0, 1, 0}
	ok := func(i, j int) bool {
		return i >= 0 && i < r && j >= 0 && j < c
	}
	for i := 0; i < r; i++ {
		for j := 0; j < c; j++ {
			switch grid[i][j] {
			case 1:
				si, sj = i, j // 起点
			case 0, 2:
				point |= 1 << (i*c + j) // 映射 [i,j]
			}
		}
	}
	//fmt.Printf("%b\n", point)
	var dfs func(int, int, int) int
	dfs = func(i, j, p int) int {
		if grid[i][j] == 2 {
			if p == 0 { // 一条成功路径
				return 1

			}
			return 0 // 一条失败路径
		}
		cnt := 0
		for k := 0; k < 4; k++ { // 四连通
			if nr, nc := i+d[k], j+d[k+1]; ok(nr, nc) {
				idx := 1 << (nr*c + nc)
				if p&idx > 0 { // 可通过的点
					cnt += dfs(nr, nc, p^idx) // 走过这个点
				}
			}
		}
		return cnt
	}
	return dfs(si, sj, point)
}

//leetcode submit region end(Prohibit modification and deletion)
